{"meta":{"title":"Kurenai's World","subtitle":"Welcome to My nightlife","description":"君を見てると、心が震える","author":"Kurenai","url":"https://www.kurenai.club","root":"/"},"pages":[{"title":"about","date":"2020-07-06T17:40:18.000Z","updated":"2021-03-24T09:05:14.866Z","comments":true,"path":"about/index.html","permalink":"https://www.kurenai.club/about/index.html","excerpt":"","text":"Hi, there I’m a/an … Windows user Android user Office worker ACGN lover Java programmer I’m currently learning … Japanese Netty Everything More information (zh_CN) My homepage"},{"title":"categories","date":"2017-02-25T21:18:30.000Z","updated":"2021-03-24T09:05:14.866Z","comments":true,"path":"categories/index.html","permalink":"https://www.kurenai.club/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-02-25T20:45:46.000Z","updated":"2021-03-24T09:05:14.902Z","comments":true,"path":"tags/index.html","permalink":"https://www.kurenai.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis笔记01","slug":"redis-note-01","date":"2021-03-24T09:18:07.000Z","updated":"2021-03-24T09:05:14.866Z","comments":true,"path":"2021/03/24/redis-note-01/","link":"","permalink":"https://www.kurenai.club/2021/03/24/redis-note-01/","excerpt":"使用Redis时有时候会碰上一些并发的问题，这里来说一下分布式锁以及加锁超时等问题。","text":"使用Redis时有时候会碰上一些并发的问题，这里来说一下分布式锁以及加锁超时等问题。 0x00一般情况下，会对那些变化不大但是访问量比较大的请求做缓存处理，但缓存会在某个时刻失效，此时就会有大量的请求涌向数据库从而容易引发雪崩效果。 0x01为了避免雪崩，我们可以在更新缓存的代码块（即访问数据库）中加入分布式锁，只能够让一个线程去做缓存更新: if (redis.setIfAbsent(lock, 1)) &#123; // 更新缓存逻辑 redis.del(lock); &#125; 但是上面如果更新逻辑出现卡死现象就会造成死锁，所以我们还需要给锁设置超时时间，但是设置超时时间一般的工具例如spring的RedisTemplate是没有把检查存在并设置值和设置超时时间作为一个请求发送的，则无法保证是原子操作，这样也会发生在设置超时时间的时候没有成功导致死锁。 由于redis新版本支持了setNX和EX复合指令的原子操作（即判断存在和设置超时时间），所以我们可以去扩展RedisTemplate或者当前使用的工具类；另一种方法则是用lua脚本，执行lua脚本也是一次原子操作。 redis在4.0之前整体都是单线程的，4.0后开始加入多线程，但也仅是部分操作，所以就算非复合指令也可以通过一个请求发送多个指令的方式来达成原子操作的目的。 if (redis.setAndExpireIfAbsent(lock, 1, 10000)) &#123; // 更新缓存逻辑 redis.del(lock); &#125; 注意redis 2.6.12 之前，set返回永远为ok，之后则设置成功时返回ok，加入条件参数不成立则返回空 0x02但我们可能还会发现另一个问题，更新逻辑太久了超过了超时时间，此时锁已经被解除了，这就会执行导致途中另一个线程获取到了锁，导致后面删除的时候是删除的另一个线程加的锁。 所以我们需要引入一个随机id，作为当前线程加锁的标识，若后面发现不是相同id则不做删除。 long random = SnowFlakeGenerator.getInstant().nextId(); if (redis.setAndExpireIfAbsent(lock, random, 10000)) &#123; // 更新缓存逻辑 if (redis.get(lock) == random) &#123; redis.del(lock); &#125; &#125; Ok，到了这里你可能也发现了，这个删除是不是也要做原子操作比较好点(没错…若是不做原子操作，那可能就会虽然拿到锁的值能够匹配上，但是下一个瞬间就因为超时而被别的其他线程获取到锁从而又引发了上面的问题，删错了别的线程的锁。 0x03类似的由于超时导致的问题还有一些情况就是计数器 synchronized (LOCK) &#123; //只是为了排除多线程情况，这里只想讨论超时问题，实际情况还要具体分析 if(redis.exists(userId)) &#123; redis.incr(); if (redis.get(userId) &gt; maxAllowedTimes) &#123; return false; &#125; return true; &#125; else &#123; redis.set(userId, 1); redis.setExpire(60000); return ture; &#125; &#125; 上面是一段限制用户一分钟内可访问次数的redis计数器。这里面如果判断到存在后的下一个瞬间恰好超时，此时incr方法在redis的行为就是先创建并设置值为0，然后加1，而没有设置过期时间。导致后面永远被限制访问。 synchronized (LOCK) &#123; if(redis.setAndExpireIfAbsent(userId, 1, 60000)) &#123; return true; &#125; else &#123; long times = redis.get(userId); if(times &lt; maxAllowedTimes) &#123; redis.setIfPresent(userId, ++times); return true; &#125; return false; &#125; &#125;","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.kurenai.club/categories/Redis/"}],"tags":[]},{"title":"Over the wall","slug":"over-the-wall","date":"2020-12-07T01:48:13.000Z","updated":"2021-03-24T09:05:14.866Z","comments":true,"path":"2020/12/07/over-the-wall/","link":"","permalink":"https://www.kurenai.club/2020/12/07/over-the-wall/","excerpt":"I will record here some information or opinions that I believe.Everything is selected based on my subjective judgment.","text":"I will record here some information or opinions that I believe.Everything is selected based on my subjective judgment. 封面 我的头像出处，《Lian》当中的女主铃音，头像以及本封面都是碟子附赠的图片。片子非常意识流，那种感觉就像第一次看 eva 一样，有点跟不上节奏，或者说觉得非常混沌。 Link 首先，把移民和工作分开：很多人移民了还是要辛苦工作其次，把移民和 “改变命运” 这件事分开：很多人移民了并没有太大的改命然后，把移民和与众不同这件事分开：很多比你条件差的人也成功了然后，把移民和鹤立鸡群这件事分开：即使你移民成功了别人也未必羡慕然后，把移民和生活中任何一件事联系起来：它就像任何一次部门间的工作调动一样平常，组织捞人 捞到你了，组织说让你去海外你就去了，就完事了（和你的个人素质并无关系：比你的英文水平好很多的人，其实也没移民；比你 IT 能力再高的人，其实也没移民；怎么就论到你移民了呢？是的，就是轮到你了。） 并不高不可攀，甚至就像喝水 然后，你会发现 V2EX 其实并不是一个特别适合讨论移民这件事的 BBS，尤其是在增强移民信心和让移民可行性落地的方面：盖因它无法像讨论一件普普通通的事情一样讨论移民，它没这心胸。 Link 不想反驳一些人的观点，毕竟每个人都有表达自己观点的权利。 但是，作为一个个体，你需要明确： 1 、你的一辈子很短，你必须优先考虑眼前的幸福，而不是未来潜在的幸福。比如，我承认中国在改善、在发展，但是在可见的未来几十年，许多问题依然不会得到解决（ e.g.建立独立的司法体系、健全对弱势群体的保护）。这是一个价值观选择题：你选择去伟大地建设这个国家，还是优先保护自己和家人？很遗憾，我比较自私，我也不是伟人，我选择短期内更能保护我个人利益（ e.g.有健全的劳动法、有工会、可以自由访问互联网并且自由交流思想）的地方。 2 、国家是一个政治概念，是一个“协议”、“合同”，而不是一种与生俱来的强加于个体的道德义务。有兴趣的可以参考这里的讨论： https://www.zhihu.com/question/48440859 。所以，不要被这种政治概念和集体思想绑架，否则你就是韭菜——或者你是站在有资源的那一边，可以利用这个概念去绑架别人、割别人韭菜。 3 、移民与否，取决于你在哪里更有优势、能活得更好。我认识的大部分回国的同学，都是在国内非富即贵的。我想了想，似乎非常合理：因为他们回去可以轻而易举地活得很好甚至随意割别人韭菜。如果你也是有本事割别人韭菜的，那就留在国内，毕竟国内机会比较多。但是如果你不属于这种，那么就想想你最在乎什么（ e.g.钱？健康？生活丰富度？稳定性？冒险刺激？相对公平的允许你靠自身努力上升的发展平台？）、如果去国外你是不是可以活得更开心（ e.g.哪些地方可以提供你在乎的这些东西）？ 没有一个国家是完美的，日韩、欧洲、美国、新加坡都有各自的问题（日韩-经济并不是很好、并不是未来的主流市场、发展上限较低；欧洲-经济也不是特别好，除了德国英国稍微好点；美国-在太平洋两岸两位书记的联手协作下，民粹主义盛行；新加坡-主要产业为金融服务业，没有太多 tech 行业的机会）。如果你想追求刺激、追求暴富，那么可能中国更适合你。 但是国内也有国内的问题——e.g.摘取 11 例器官判 2 年 4 个月，写小黄书判 10 年半； 996 是常态；弱势群体随时有可能被“集体”绑架和以“维护集体利益”的名义牺牲。坦白说，中国虽然近年经济发展迅速，但是在对国民个体的保护上与西方国家还差着一整个“文艺复兴”（西方所有价值观的基础——“以人为本、破除神权”）。如果你觉得自己是一个弱势群体，那么可能中国对你来说就是 hard 模式。 最后，再次非常诚恳地建议很多和我一样的“弱势群体”，不要被别人割了韭菜，还帮着人家吆喝。保护好自己和家人、健康快乐地过好自己短暂的一生，这才是最重要的、这也是作为一个人的基本天性和权利—— [身为韭菜，不要自己给自己画饼] 。 Link 另外关于移民途径，似乎现在还是挺多的——人口减少是许多发达国家面临的巨大挑战，所以只要你年轻还是有很多机会的。全球发达国家中似乎只有美国是移民非常难的。 1 、加拿大——读书、拿工作签、枫叶卡；甚至如果不去加拿大读书和工作也可以直接申请枫叶卡，只要你打分足够——年纪轻加分、高学历加分、工作经验加分（自行搜索加拿大移民 Express Entry 打分系统）；2 、新加坡——只要能找到工作就能申请到工作签和之后申请绿卡，没有名额限制。位于新加坡的 tech 公司虽然不多，但还是有几家，之前在 v 站也看到过相关的招人贴，请自行搜索；3 、欧洲——只要能找到工作，就能申请到工作签并且之后申请绿卡，无名额限制。但是直接找欧洲工作比较难找，因为欧洲人自己找工作本身就比较难了（尤其是英国，暂且还是把英国算在欧洲吧 lol ）。加入国际公司再申请内部 relocation 的思路比较有实操意义，前提是你能说服老板为什么要 relocate 。要么就还是读书、工作签、申请绿卡，也不是很难。4 、美国——除非能直接找到工作并且申请到 H1B，或者加入在华美国公司一年后以 L1 签证调来美国；要么就是读书、找工作、申请 H1B 、申请绿卡；要么就是投资移民、结婚移民等途径了。5 、日韩——不清楚，按理说也不会很难。 途径还是一直有的，就看你愿不愿意冒险和花成本了。经济上，我之前也见过许多国际学生贷款来读书的——可能国内觉得不可思议，但是美国挺常见的，如果你读 MBA 或者 JD 或者 STEM 这种未来赚钱能力强的学位，无需美国人担保即可贷款，请自行搜索 Prodigy Finance 。学校申请上，你如果是为了找工作，未必一定要申请顶尖名校，找工作够用就行。 所以，加油！","categories":[],"tags":[]},{"title":"学习JPA笔记——构建复杂查询","slug":"learning-jpa-02","date":"2020-10-06T09:25:19.000Z","updated":"2021-03-24T09:05:14.866Z","comments":true,"path":"2020/10/06/learning-jpa-02/","link":"","permalink":"https://www.kurenai.club/2020/10/06/learning-jpa-02/","excerpt":"本篇介绍两种 JPA 做复杂查询的方法，一个是用 SpringDataJPA 实现， 一个是用 Java EE 实现。","text":"本篇介绍两种 JPA 做复杂查询的方法，一个是用 SpringDataJPA 实现， 一个是用 Java EE 实现。 封面：同上篇，这次前景就是最高机密 Viper Zero。嗯，没啥问题，每集一张，只是PS了 ForewordJPA以及其他类似东西之间的关系在进入正题之前还是稍微提一下这几个东西之间的关系。首先JPA是一种规范，Java EE 中有把这种规范抽象出来的接口，具体实现是看用的什么框架，可以是 Hibernate 或者是 EclipseLink 等。而这之中 Spring 又对 Java EE 中的接口再次封装，以更好地整合进 Spring 体系当中，但 SpringDataJPA 仍然是个抽象，具体实现仍然是看选型的框架。但日常中，由于 SpringDataJPA 默认是 Hibernate 实现，所以一般场合基本相当于 Hibernate。 个人对于数据库复杂查询的理解或看法对于联表这些事情我个人的感受来说是极为痛苦的，表面上可以不多此查询数据库，不查询多余数据，不需要程序做多次遍历。其实在一些压力不大的场景中，这些都显得很无所谓。多次连接有缓存，多次遍历实际消耗也不大，多余数据实际上做 join 的时候就会拿过来，join 中加入条件也和第二次查询加入条件差不多。但实际上最麻烦的，是当真正数据库压力上来了，这些操作都没有太大意义，最后还是会在数据库和程序此之间加入缓存，把数据库做的很多事情放到程序当中去做，尽量减低数据库压力。而此时你就会发现之前做的联表查询之类的就像是外来物一样格格不入。 所以我对此也非常欣赏DDD的设计美感。 SpringDataJPASpringDataJPA 的复杂查询除了直接写 sql，按照规则定义 Repository 接口方法以外，还可以使用Specification做查询。 Specification这是SpringDataJPA抽象出的一个接口，故并不一定通用于其他JPA的实现。该接口重点在于toPredicate方法，该方法将创建一个 where 语句对象。 public interface Specification&lt;T&gt; extends Serializable &#123; ... /** * Creates a WHERE clause for a query of the referenced entity in form of a Predicate for the given * Root and CriteriaQuery. */ @Nullable Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder); &#125; 这里我只做简要说明，以便于理解，仅供参考。 root： 一般指实体类本身，包装成 Root 对象, 可由query.from(Post.class)得到Root&lt;Post&gt;，Java EE 会提到。 query： sql语句对象，一般在此方法内部不做调用，Java EE 会给一些用于理解的调用。 criteriaBuilder： 用于构建条件语句。 个人建议是不要管我说的这些，真要去理解就看源码注释，或者看下面 Java EE 的代码，更能够理解。 Getting Started首先我们创建一个 Repository 接口，并继承JpaSpecificationExecutor&lt;T&gt;以获得复杂查询的能力。 public interface PostRepository extends JpaSpecificationExecutor&lt;Post&gt; &#123; &#125; 然后我们运用 java8 所带来的新特性，使用 lambda 构建一个匿名 Specification 的实现类，并实现 toPredicate 方法。 repository.findAll( (Specification&lt;Post&gt;) (root, criteriaQuery, builder) -&gt; &#123; // where title like '%Test%'; return builder.like(root.get(Post_.title), \"%Test%\") // 如果是多个条件，例如 where title like '%Test%' and content like '%Test%' and id &lt; 10; return builder.and(builder.like(root.get(Post_.title), \"%Test%\"), builder.like(root.get(Post_.content), \"%Test%\"), builder.le(root.get(Post_.id), 10)) // 而如果我们没有做 Typesafe，那么就会变成这样 return builder.like(root.get(\"title\"), \"%Test%\") &#125; ); 使用起来其实没什么困难，基本举一反三，其他的复杂查询我暂时没研究，主要是觉得可以避开用别的方法操作，或者提到程序中操作。 Java EE实际上，SpringDataJPA 是对 Java EE 原本的 JPA 抽象再次包装了一层，所以这个可以说是原汁原味了。 Getting Stated由于我主要使用 SpringDataJPA 所以摘抄了一段代码，出处。 //需要对此进行注入 private final EntityManage entityManager; String q; int offset, limit; CriteriaBuilder cb = this.entityManager.getCriteriaBuilder(); // create query CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class); // set the root class Root&lt;Post&gt; root = query.from(Post.class); // if keyword is provided if (q != null &amp;&amp; !q.trim().isEmpty()) &#123; // 这里其实就是上面 toPredicate 返回的对象作为参数传入where方法当中，所以里面就和上面的实现没有什么太大区别。 query.where( cb.or( cb.like(root.get(Post_.title), \"%\" + q + \"%\"), cb.like(root.get(Post_.content), \"%\" + q + \"%\") ) ); &#125; //perform query return this.entityManager.createQuery(query) .setFirstResult(offset) .setMaxResults(limit) .getResultList(); EntityManager 实体管理类，用于与持久化上下文进行互动，核心类。 其他几个 Root、CriteriaQuery、CriteriaBuilder 作用同上，毕竟spring只是做了封装。看完上面代码，大致就能够了解清楚这几个类分别是怎么使用的了，总体来说其实比上面spring的实现所接触到的东西更加全面一些，也能够理解这几个类互相是怎么作用的了。 Referencehelidon-sample @ hantsy","categories":[{"name":"Java","slug":"Java","permalink":"https://www.kurenai.club/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kurenai.club/tags/Java/"},{"name":"ORM","slug":"ORM","permalink":"https://www.kurenai.club/tags/ORM/"},{"name":"JPA","slug":"JPA","permalink":"https://www.kurenai.club/tags/JPA/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://www.kurenai.club/tags/Hibernate/"}]},{"title":"学习JPA笔记——使用MetaModel实现Typesafe","slug":"learning-jpa-01","date":"2020-10-06T07:25:51.000Z","updated":"2021-03-24T09:05:14.866Z","comments":true,"path":"2020/10/06/learning-jpa-01/","link":"","permalink":"https://www.kurenai.club/2020/10/06/learning-jpa-01/","excerpt":"本篇主要说 Typesafe，下一篇讲一下 JPA 构建复杂查询。项目极简代码在这","text":"本篇主要说 Typesafe，下一篇讲一下 JPA 构建复杂查询。项目极简代码在这 封面：动画「ガーリー・エアフォース」#08的 EDCard，算是原作插画师@遠坂あさぎ的贺图，每集一张。有趣的是因为最高机密的特性导致男主看到的样子和幼馴染一样，而此时他的幼馴染正生着气，所以标题叫不高兴的最高机密w 最近看了@hantsy大大在V站的帖子（这里、这里），就开始心血来潮想要看看 JPA 怎么玩，另外就是大大所说的 Typesafe 要这么实现。 注意：这里不会对JPA大多的基础知识进行说明，文章本意是做一次笔记，必要时请充分发挥自主能动性进行查找学习 Typesafe我的理解是不要那种无法编译时无法检验出错误或者 IDE 无法帮助我们检验错误的字符串，而这里比较突出的就是字段名。 我司其实也是内部写了一套 orm，只是基本不在意 Typesafe，而更加注重方便直接编写复杂 sql 而已。 而没有编译时的检测或者是 IDE 的检测，就难免出现 Typo，更加糟糕的是后期维护时的修改会造成一种我还有哪里用到了这个字段的尴尬状况，一旦遗漏就只能等运行时才可以检测出了。 为了解决这一状况，我们可以用到 MetaModel 生成器，例如 Hibernate 就有相应的生成器jpamodelgen（这类 MetaModel 生成器是为了实现 JPA2.0 标准的，具体我没有细查） 除了 Hibernate 以外，EclipseLink 也有这类生成器，各位可以自己去玩玩。我由于直接用 SpringDataJpa，而 spring 默认使用 Hibernate，所以就没有折腾别的了。 Getting Started下面是我整合了Lombok生成器的配置，仅供参考。也可以看看这篇文章，有多种玩法。 &lt;project&gt; ... &lt;dependencies&gt; ... &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt; &lt;version&gt;5.4.21.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 如果不是用SpringDataJpa的话，需要额外引入下面的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt; &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ... &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths &gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.bsc.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-processor-plugin&lt;/artifactId&gt; &lt;version&gt;4.3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;process&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;process&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;configuration&gt; &lt;processors&gt; &lt;processor&gt;org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor&lt;/processor&gt; &lt;/processors&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt; &lt;version&gt;5.4.21.Final&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 添加完后，在实体类添加@Entity和@Id的注解使生成器生效，例如： @Entity @Data public class Post implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) int id; String title; String content; @Enumerated(EnumType.STRING) Status status = Status.DRAFT; LocalDateTime createdAt; @Transient String excludeColumn; static enum Status&#123;DRAFT, PUBLISHED&#125; public static Post of(String title, String content) &#123; Post post = new Post(); post.setCreatedAt(LocalDateTime.now()); post.setTitle(title); post.setContent(content); return post; &#125; &#125; 添加完后对代码进行编译，生成器则会找到该注解的类生成这样的类： @Generated(value = \"org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor\") @StaticMetamodel(Post.class) public abstract class Post_ &#123; public static volatile SingularAttribute&lt;Post, LocalDateTime&gt; createdAt; public static volatile SingularAttribute&lt;Post, Integer&gt; id; public static volatile SingularAttribute&lt;Post, String&gt; title; public static volatile SingularAttribute&lt;Post, String&gt; content; public static volatile SingularAttribute&lt;Post, Status&gt; status; public static final String CREATED_AT = \"createdAt\"; public static final String ID = \"id\"; public static final String TITLE = \"title\"; public static final String CONTENT = \"content\"; public static final String STATUS = \"status\"; &#125; 而当我们运行程序时，SingularAttribute 类型的对象则会被自动赋值，之后在调用 JPA 的 API 时则可以作为参数传入，而不是传入字符串了。调用时看起来是这样子的： repository.findAll((Specification&lt;Post&gt;) (root, criteriaQuery, builder) -&gt; builder.like(root.get(Post_.title), \"%Test%\")) 我说什么来着，不用字符串其实这里就不太需要追求这些，而字段这些是带关联性的，会在好多个地方出现，有必要对其进行检测。对于人类而言，检测总是会犯错，所以这些最好是交由机器来帮忙，也能够让我们更加关注业务。 Referencehelidon-sample @ hantsyHibernate JPA 2 Metamodel Generator","categories":[{"name":"Java","slug":"Java","permalink":"https://www.kurenai.club/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kurenai.club/tags/Java/"},{"name":"ORM","slug":"ORM","permalink":"https://www.kurenai.club/tags/ORM/"},{"name":"JPA","slug":"JPA","permalink":"https://www.kurenai.club/tags/JPA/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://www.kurenai.club/tags/Hibernate/"}]},{"title":"Reactor中的上下文","slug":"context-of-reactor","date":"2020-09-08T22:53:22.000Z","updated":"2021-03-24T09:05:14.866Z","comments":true,"path":"2020/09/08/context-of-reactor/","link":"","permalink":"https://www.kurenai.club/2020/09/08/context-of-reactor/","excerpt":"由于参与的项目当中决定用 spring-cloud-gateway 作为网关，所以自然就碰上了Reactor当中获取上下文的问题。 这里我是遇到了 I18N 需要获取上下文中 Locale 的问题，所以我就以这个问题举例，提供其中一种上下文的解决方法。","text":"由于参与的项目当中决定用 spring-cloud-gateway 作为网关，所以自然就碰上了Reactor当中获取上下文的问题。 这里我是遇到了 I18N 需要获取上下文中 Locale 的问题，所以我就以这个问题举例，提供其中一种上下文的解决方法。 What happened在使用 I18N 进行国际化时，Servlet 框架下我们通常会使用 ThreadLocal 进行储存解析请求得到上下文的 Locale 对象，以判断当前请求需要的是什么语言。但在 Reactor 框架下，由于一个请求整个流程下来，线程都在不断的进行切换，所以 ThreadLocal 自然也就失去上下文储存对象的能力。 经过简单的谷歌查询，我只能想两种处理方法： 从 controller 获取 Locale 或者任意能够得到 Exchange（类似 Request）的方法开始一路传递下去。 直接将 I18N 的 key 传入自定义异常对象当中，然后在统一异常处理类当中获取 Exchange 再做进一步的国际化操作。 但他们都不够优雅，而且其中弊端也很明显，一个是需要无限传递变量，一个是只能限制再异常处理类进行处理，理所当然就无法添加国际化的变量。 How should I do如何取值令人喜悦的是，Spring 其实已经写了一个获取上下文的例子了，它就是ReactiveSecurityContextHolder，对应 Servlet 当中的SecurityContextHolder。 ReactiveSecurityContextHolder#getContext private static final Class&lt;?&gt; SECURITY_CONTEXT_KEY = SecurityContext.class; public static Mono&lt;SecurityContext&gt; getContext() &#123; return Mono.subscriberContext() .filter( c -&gt; c.hasKey(SECURITY_CONTEXT_KEY)) .flatMap( c-&gt; c.&lt;Mono&lt;SecurityContext&gt;&gt;get(SECURITY_CONTEXT_KEY)); &#125; 可以看到，通过Mono.subscriberContext()，我们可以得到一个上下文对象，然后他先判断是否包含给出的key值，包含则获取值。这里需要注意，如果直接获取值会抛出异常。 如何赋值当我查看withSecurityContext方法时，其注释告诉我是用来创建一个包含SecurityContext的 Reactor 上下文对象（Context）并可被用于与其他上下文对象（Context）进行合并。 所以当我们查看有什么方法调用它时，就会发现ReactorContextWebFilter这个过滤器。 public class ReactorContextWebFilter implements WebFilter &#123; private final ServerSecurityContextRepository repository; public ReactorContextWebFilter(ServerSecurityContextRepository repository) &#123; Assert.notNull(repository, \"repository cannot be null\"); this.repository = repository; &#125; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) &#123; return chain.filter(exchange) .subscriberContext(c -&gt; c.hasKey(SecurityContext.class) ? c : withSecurityContext(c, exchange) ); &#125; private Context withSecurityContext(Context mainContext, ServerWebExchange exchange) &#123; return mainContext.putAll(this.repository.load(exchange) .as(ReactiveSecurityContextHolder::withSecurityContext)); &#125; &#125; ServerSecurityContextRepository#load public Mono&lt;SecurityContext&gt; load(ServerWebExchange exchange) &#123; return exchange.getSession() .map(WebSession::getAttributes) .flatMap( attrs -&gt; &#123; SecurityContext context = (SecurityContext) attrs.get(this.springSecurityContextAttrName); return Mono.justOrEmpty(context); &#125;); &#125; ReactiveSecurityContextHolder#withSecurityContext public static Context withSecurityContext(Mono&lt;? extends SecurityContext&gt; securityContext) &#123; return Context.of(SECURITY_CONTEXT_KEY, securityContext); &#125; 通过阅读上面的代码可得知，上面的过滤器通过ServerSecurityContextRepository解析请求中的 Security 上下文，通过ReactiveSecurityContextHolder生成 Securtiy 上下文对象并返回。 Finally我们可以仿照着写一个从请求对象当中解析出一个 Locale 对象并放入上下文当中（不确定是不是上下文，但是Reactor确实是用这种办法实现了上下文的功能）。 // 将 Locale 放到上下文中 public class ReactorLocaleContextWebFilter implements WebFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) &#123; return chain.filter(exchange) .subscriberContext(c -&gt; c.hasKey(Locale.class) ? c : withLocaleContext(c, exchange) ); &#125; private Context withLocaleContext(Context mainContext, ServerWebExchange exchange) &#123; //解析请求获取 Locale Locale locale = getLocale(exchcange); return mainContext.putAll(Context.of(Locale.class, Mono.justOrEmpty(locale))); &#125; &#125; //获取 Locale Mono.subscriberContext() .filter( c -&gt; c.hasKey(Locale.class)) .flatMap( c-&gt; c.&lt;Mono&lt;Locale&gt;&gt;get(Locale.class)); 具体实现我日后会写一个demo。咕咕咕","categories":[{"name":"Java","slug":"Java","permalink":"https://www.kurenai.club/categories/Java/"},{"name":"Reactor","slug":"Java/Reactor","permalink":"https://www.kurenai.club/categories/Java/Reactor/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kurenai.club/tags/Java/"},{"name":"Reactor","slug":"Reactor","permalink":"https://www.kurenai.club/tags/Reactor/"},{"name":"Webflux","slug":"Webflux","permalink":"https://www.kurenai.club/tags/Webflux/"},{"name":"Spring","slug":"Spring","permalink":"https://www.kurenai.club/tags/Spring/"}]},{"title":"Reactor处理阻塞问题笔记","slug":"lean-pulishOn-of-reactor","date":"2020-03-03T09:53:22.000Z","updated":"2021-03-24T09:05:14.866Z","comments":true,"path":"2020/03/03/lean-pulishOn-of-reactor/","link":"","permalink":"https://www.kurenai.club/2020/03/03/lean-pulishOn-of-reactor/","excerpt":"其实本来想要记录问题的过程，但奈何自己也说不太好XD","text":"其实本来想要记录问题的过程，但奈何自己也说不太好XD What由于接触Vert.x以及阅读其文档后，了解到异步编程下是不能够阻塞主线程的，不然异步将失去意义。 我们需要做的是将这些阻塞线程移到其他线程进行处理。 How利用Mono或是Flux的PublishOn方法将之后调用的方法都移动到其他线程进行处理。 publishOn public final Mono&lt;T&gt; publishOn(Scheduler scheduler); public final Flux&lt;T&gt; publishOn(Scheduler scheduler); 其中Scheduler可用Schedulers.parallel()或Schedulers.single()进项创建或是其他方法，其中single和parallel是有一些区别的。 single 这一条调用链下不会同时执行，并且只有这条调用链执行完成后才会再次被调用 parallel 与上面相反，调用链会在同时执行 下面是测试代码 本人只是刚开始玩reactor，程序写的很蹩脚XD @Test public void test() throws IOException &#123; AtomicReference&lt;Employee&gt; employeeAR = new AtomicReference&lt;&gt;(); //&lt;1&gt; Scheduler scheduler = Schedulers.single(); //&lt;2&gt; for (int i = 0; i &lt; 5; i++) &#123; int finalI = i; Mono.just(1) .publishOn(scheduler) .map(x -&gt; &#123; try &#123; Thread.sleep(1000); System.out.println(finalI + \"-\" + Thread.currentThread() .getName() + \"-A\"); //&lt;3&gt; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Employee emp = buildEmployee(); employeeAR.set(emp); //&lt;1&gt; return emp; &#125;) .map(x -&gt; &#123; try &#123; System.out.println(finalI + \"-\" + Thread.currentThread() .getName() + \"-B\"); //&lt;3&gt; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return x; &#125;) .map(x -&gt; &#123; System.out.println(finalI + \"-\" + Thread.currentThread() .getName() + \"-C\"); //&lt;3&gt; return employeeAR.get().getAccountId(); //&lt;1&gt; &#125;) .subscribe(System.out::println); System.out.println(Thread.currentThread() .getName()); //&lt;3&gt; &#125; char c = (char) System.in.read(); System.out.println(\"your char is: \" + c); &#125; &lt;1&gt; 因为涉及到匿名方法中的变量的再次调用，所以用到AtomicReference进行储存。 下面是single的运行结果 main main main main main 0-single-1-A 0-single-1-B 0-single-1-C 123 1-single-1-A 1-single-1-B 1-single-1-C 123 2-single-1-A 2-single-1-B 2-single-1-C 123 3-single-1-A 3-single-1-B 3-single-1-C 123 4-single-1-A 4-single-1-B 4-single-1-C 123 将&lt;2&gt;中single改为parallel main main main main main 0-parallel-1-A 3-parallel-4-A 2-parallel-3-A 4-parallel-5-A 0-parallel-1-B 3-parallel-4-B 2-parallel-3-B 1-parallel-2-A 1-parallel-2-B 4-parallel-5-B 0-parallel-1-C 1-parallel-2-C 3-parallel-4-C 4-parallel-5-C 2-parallel-3-C 123 123 123 123 123 观察代码中&lt;3&gt;，我们可以发现调用链当中是按照顺序执行的（我最开始以为会平行执行调用链中的方法，但并不是），而且主线程也没有被阻塞，能够快速输出当前线程名称，由此可见已经达到我们最初的目的了——不阻塞主线程。 Why在这里我用的是Spring WebFlux，而其中会用到netty，其中有一个Eventloop模块，这是由单个线程运行的模块，这个单线程就是由我们程序所运行的主线程来担当。 Eventloop会重复检查当前有没有事件产生，若有则会接收该事件并运行相应的事件响应，也就是发布订阅模式，而如果我们在其中一个调用该事件的响应方法中等待（阻塞）过久，就会导致我们无法快速处理后续产生的事件，只能够加多线程进行快速处理，这就又回到了非异步编程当中去了。 所以能够快速响应才能够体现出异步编程的优势。 Reference Is there a standard way to solve blocking that must happen. How to handle blocking calls when using reactor in a JAX-RS-powered server? TODO 测试嵌套调用publishiOn是什么情况 是否是调用一次publishOn后，后面的链式调用都是在另一条线程，是否需要再次调用一次pubulishOn保证之后的一次阻塞操作也不在主线程当中 补充详细Evenloop 寻找更加优雅的方式，或者看看这种链式调用是不是也是一个不太好的地方","categories":[{"name":"Java","slug":"Java","permalink":"https://www.kurenai.club/categories/Java/"},{"name":"Reactor","slug":"Java/Reactor","permalink":"https://www.kurenai.club/categories/Java/Reactor/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kurenai.club/tags/Java/"},{"name":"Reactor","slug":"Reactor","permalink":"https://www.kurenai.club/tags/Reactor/"},{"name":"Webflux","slug":"Webflux","permalink":"https://www.kurenai.club/tags/Webflux/"},{"name":"Spring","slug":"Spring","permalink":"https://www.kurenai.club/tags/Spring/"}]},{"title":"Re：从零开始的领域驱动设计","slug":"DDD","date":"2019-08-11T00:00:00.000Z","updated":"2021-03-24T09:05:14.858Z","comments":true,"path":"2019/08/11/DDD/","link":"","permalink":"https://www.kurenai.club/2019/08/11/DDD/","excerpt":"领域驱动设计(Domain-driven design)，缩写为DDD。以领域设计为驱动，构建整一个系统。 这个设计思想是在微服务开始流行时逐渐变得火爆的，因为其设计理念非常适合分布式的微服务拆分。","text":"领域驱动设计(Domain-driven design)，缩写为DDD。以领域设计为驱动，构建整一个系统。 这个设计思想是在微服务开始流行时逐渐变得火爆的，因为其设计理念非常适合分布式的微服务拆分。 我声明一点，本文章其实都是东拼西凑的，里面所表达的仅仅是个人的理解（我没有读完ddd那本书） 通用语言(Ubiquitous Language)通用语言其实就是把模型通过大家都能够理解的语言表达出来。 通常我们在开发业务的过程中都是先去调研，了解其业务的具体细节，并商讨大致的程序设计，然后经过开发人员转化成为代码，在这个过程中交流是单向性的，直到下一次需要展示或者有理解出现错误时才会与客户或者是业务人员再次交流。 而业务人员那边通常也只能通过表面的程序看问题，无法理解其实际运作是否符合业务人员所想，这可能将导致程序在错误的方向上越走越远 领域驱动设计是需要建立一个通用语言的，这需要领域专家(即对这些业务整体非常熟悉的人)与开发人员一同参与 我们需要把程序设计上的事情通过一个通用的语言表述出去使领域专家能够理解我们是如何通过程序设计业务的，而领域专家也同样需要把那些专业名词，业务场景用通用语言描述出来 当我们有了通用语言后，我们就能够在建立领域对象的时候听取专家的意见，同时能够让专家理解领域对象是否符合他们的预期 而形成通用语言是不容易的，因为其答案并不唯一，不同的人会有不同的理解，从而导致不同的答案。但我们可以试着从UML或是伪代码着手 航运例子 层结构(Layered Architecture) User Interface负责向用户展现信息，并且会解析用户行为，即常说的展现层。 Application Layer应用层没有任何的业务逻辑代码，它很简单，它主要为程序提供任务处理。 Domain Layer这一层包含有关领域的信息，是业务的核心，领域模型的状态都直接或间接（持久化至数据库）存储在这一层。 Infrastructure Layer为其他层提供底层依赖操作。 模型关系图(Model-Driven Design) 服务(Services)当我们在分析某一领域时，一直在尝试如何将信息转化为领域模型，但并非所有的点我们都能用Model来涵盖。对象应当有属性，状态和行为，但有时领域中有一些行为是无法映射到具体的对象中的，我们也不能强行将其放入在某一个模型对象中，而将其单独作为一个方法又没有地方，此时就需要服务 工厂(Factories)在大型系统中，实体和聚合通常是很复杂的，这就导致了很难去通过构造器来创建对象。工厂就决解了这个问题，它把创建对象的细节封装起来，巧妙的实现了依赖反转。当然对聚合也适用（当建立了聚合根时，其他对象可以自动创建） 仓库(Repository)仓库封装了获取对象的逻辑，领域对象无须和底层数据库交互，它只需要从仓库中获取对象即可。仓库可以存储对象的引用，当一个对象被创建后，它可能会被存储到仓库中，那么下次就可以从仓库取。如果用户请求的数据没在仓库中，则会从数据库里取，这就减少了底层交互的次数 边界上下文(Bounded Context)简单来说就是定义该领域模型的适用范围以及使用场景。 可以这样理解： 边界(Bounded)即有边界的，表示领域模型有边界；这个边界定义了模型的适用范围，以便让负责该模型的团队知道什么该在模型中实现，什么不该； 上下文(Context)即领域模型的产生是在某个上下文中产生的；上下文是一个和环境相关的概念。比如一次头脑风暴会议大家达成了一个模型，那这次会议的讨论就是该模型的上下文；比如某本书中谈到了某个东西，那这个东西的上下文就是那本书，那个东西要有意义的前提离不开那本书这个上下文；所以，上下文是模型有意义的前提； 实体(Entity) 和 值对象(ValueObject)一言蔽之，实体大致可以理解为我们传统开发的实体，但是他具有自己的行为，而不是POJO(只具有简单的getter,setter)；值对象是指描述一个实体某个属性的对象。当然，这些都是需要在上面所说的BoundedContext被指定的前提下讨论。 举个例子：在电商系统我们现在分成两个模块，一个商品模块，一个订单模块订单对象中有收货地址(address) class Order &#123; int id; String address; &#125; 我们把address扩展开来 class Order &#123; int id; Address address; &#125; class Address &#123; String province;//省 String city;//市 String street;//街道 &#125; 现在Address是一个对象了，但是我们不会认为他是一个实体，因为在这个订单模块中它只是描述了订单中的收货地址而已，仅仅只是order上的一个值，几个内部的值所组合出的抽象，你完全可以把它理解为是一个Map: class Order &#123; int id; Map&lt;String, String&gt; address; //address Map&#123;\"province\":\"\",\"city\":\"\",\"street\":\"\"&#125; &#125; 这跟java中String对象非常类似，String对象是不会进行修改的，如果你将新的一串字符串重新赋值给一个String对象，实际上等于new了一个String，地址是变化了的，不再是同一个对象。 所以ValueObject有这样几个特点: 没有标识(唯一标识) 不可变(只读) 不具备生命周期 聚合(Aggregates) 和 聚合(Aggregate Root)聚合可以看作是多个实体之间的组合，而每个聚合都有一个根实体，叫聚合根。 在DDD当中，聚合外部想要访问聚合内的信息，必须通过聚合根进行访问。 如何识别聚合和聚合根？首先一个边界上下文(Bounded Context)可能包含多个聚合，每个聚合都有一个聚合根。 找出哪些实体可能是聚合根 逐个分析每个聚合根的边界，即该聚合根应该聚合哪些实体或值对象 划分边界上下文 如何确定聚合边界？边界的确定法则是根据不变性约束规则（Invariant）: 聚合边界内必须具有哪些信息，如果没有这些信息就不能称为一个有效的聚合 聚合内的某些对象的状态必须满足某个业务规则 如何找到聚合根？如果存在一个业务操作是完全面向某个实体，那么这个实体就可能是一个聚合根 例子分析 Order（一 个订单）必须有对应的客户信息，否则就不能称为一个有效的Order同理，Order对OrderLineItem有不变性约束，Order也必须至少有一个OrderLineItem(一条订单明细)，否则就不能称为一个有效的Order另外，Order中的任何OrderLineItem的数量都不能为0，否则认为该OrderLineItem是无效的，同时可以推理出Order也可能是无效的。因为如果允许一个OrderLineItem的数量为0的话，就意味着可能会出现所有OrderLineItem的数量都为0，这就导致整个Order的总价为0，这是没有任何意义的，是不允许的，从而导致Order无效所以，必须要求 Order中所有的OrderLineItem的数量都不能为0那么现在可以确定的是Order必须包含一些OrderLineItem，那么应该是通 过引用的方式还是ID关联的方式来表达这种包含关系呢？这就需要引出另外一个问题，那就是先要分析出是OrderLineItem是否是一个独立的聚合根。回答了这个问题，那么根据上面的规则就知道应该用对象引用还是用ID关联了。那么OrderLineItem是否是一个独立的聚合根呢？因为聚合根意 味着是某个聚合的根，而聚合有代表着某个上下文边界，而一个上下文边界又代表着某个独立的业务场景，这个业务场景操作的唯一对象总是该上下文边界内的聚合 根。想到这里，我们就可以想想，有没有什么场景是会绕开订单直接对某个订单明细进行操作的。也就是在这种情况下，我们 是以OrderLineItem为主体，完全是在面向OrderLineItem在做业务操作。有这种业务场景吗？没有，我们对 OrderLineItem的所有的操作都是以Order为出发点，我们总是会面向整个Order在做业务操作，比如向Order中增加明细，修改 Order的某个明细对应的商品的购买数量，从Order中移除某个明细，等等类似操作，我们从来不会从OrderlineItem为出发点去执行一些业 务操作；另外，从生命周期的角度去理解，那么OrderLineItem离开Order没有任何存在的意义，也就是说OrderLineItem的生命周 期是从属于Order的。所以，我们可以很确信的回答，OrderLineItem是一个实体。 Event Souring(事件溯源)Event Souring是Martin Fowler提出的一种架构模式，其特点是： 整个系统由事件进行驱动 事件是一等公民，系统的基础数据是事件，事件需要被储存在数据库中 业务数据只是由事件产生的视图，不一定需要存储在数据库 这里展示的例子是一个银行账户经历的几个事件：创建 -&gt; 存款300 -&gt; 存款100 -&gt; 取出200 在这样的设计下，每个对象都需要经历一系列的事件才会转化成现在的状态，当我们只需要进行查询的时候，这些操作未免显得太过累赘，所以我们可以把对象的最终状态存入一个视图数据库，当需要查询的时候直接查询这个数据库即可 CQRS(命令查询责任分离)CQRS简单理解就是读写分离，但它的实现可能相对其定义要复杂些，并且通常都是会和Event Souring一起被提及 参考资料： 《领域驱动设计：软件核心复杂性应对之道》 深入浅出Event Sourcing和CQRS Re：从零开始的领域驱动设计 一个DDD指导下的实体类设计案例 DDD领域驱动设计基本理论知识总结 多研究些架构，少谈些框架","categories":[{"name":"Java","slug":"Java","permalink":"https://www.kurenai.club/categories/Java/"}],"tags":[{"name":"DDD","slug":"DDD","permalink":"https://www.kurenai.club/tags/DDD/"},{"name":"CQRS","slug":"CQRS","permalink":"https://www.kurenai.club/tags/CQRS/"},{"name":"Event Sourcing","slug":"Event-Sourcing","permalink":"https://www.kurenai.club/tags/Event-Sourcing/"},{"name":"Java","slug":"Java","permalink":"https://www.kurenai.club/tags/Java/"}]},{"title":"将项目部署在docker中","slug":"将项目部署在docker中","date":"2019-03-14T11:39:00.000Z","updated":"2021-03-24T09:05:14.866Z","comments":true,"path":"2019/03/14/将项目部署在docker中/","link":"","permalink":"https://www.kurenai.club/2019/03/14/将项目部署在docker中/","excerpt":"docker中有两个概念，容器与镜像。 镜像我们可以简单的理解为是装机用的光盘，而容器就是我们用光盘所装的一个系统。实际上我们就是由镜像生成一个容器，一个镜像可以生成多个容器（只要容器互不相冲突）。 而镜像的生成就是由配置文件来决定（配置文件参数可由后期运行指令等等操作更改），具体如何配置不详细说明。","text":"docker中有两个概念，容器与镜像。 镜像我们可以简单的理解为是装机用的光盘，而容器就是我们用光盘所装的一个系统。实际上我们就是由镜像生成一个容器，一个镜像可以生成多个容器（只要容器互不相冲突）。 而镜像的生成就是由配置文件来决定（配置文件参数可由后期运行指令等等操作更改），具体如何配置不详细说明。 Banner: カントク - COLORS 配置文件例子Dockerfile #后端java项目 #基础镜像 FROM 192.168.1.2:5000/library/centos-jdk:1.7.79 #作者 MAINTAINER kurenai kurenai@moe.com #执行命令，主要用来安装相关的软件 #RUN #添加文件 ADD target/supervise-svc-0.0.1-SNAPSHOT.jar /usr/local RUN chmod u+x /usr/local/supervise-svc-0.0.1-SNAPSHOT.jar #挂载目录到容器 #VOLUME [\"/data\"] #环境变量设置 #ENV #开放端口 EXPOSE 1234 #启动时执行的命令 CMD [\"/bin/bash\"] #启动时执行的命令 ENTRYPOINT [\"java\",\"-jar\",\"-Xms2048m\", \"-Xmx2048m\", \"-XX:PermSize=256M\", \"-XX:MaxPermSize=256M\",\"/usr/local/supervise-svc-0.0.1-SNAPSHOT.jar\"] #前端react项目 #基础镜像 FROM xxx.xxx.com:5000/library/ui-nginx:latest #维护人信息 MAINTAINER WenboLI liwenbo@ly-sky.com #工作目录 WORKDIR /usr/local/nginx ADD ui.tar.gz /usr/local/nginx/html/ ADD nginx.conf /usr/local/nginx/conf/ #暴露端口 EXPOSE 80 #连接时执行的命令 CMD [\"/bin/bash\"] #启动时执行的命令 #ENTRYPOINT nginx -g \"daemon off;\" ENTRYPOINT /opt/run.sh 基础命令 docker ps #查看doker中正在运行的容器列表 docker images #查看docker中的镜像列表 docker build #将当前目录下的文件打包为镜像 docker rm #移除容器 docker rmi #移除镜像 docker pull #拉取镜像 docker logs -f #查看日志 docker restart #重启容器 docker stop #停止容器运行 docker-compose能够比较集中的管理镜像和容器的部署问题，不必用像原生docker那样一个一个项目进行打包镜像生成容器，只需要把n个项目的配置写在配置文件中即可进行批量打包，拉取镜像，生成容器 配置文件例子docker-compose.yml version: '2.2' services: #项目名称，用docker-compose做管理时，每个项目用这里配置的名称进行单独管理 base: #镜像名，拉取镜像时也是用这个名字作为地址 image: 192.168.1.2:5000/test/base-svc:0.0.1-SNAPSHOT #打包路径，即docker build的路径 build: /opt/dockerfile/base-svc restart: always #环境变量 environment: defaultZone: http://192.168.1.3:1200/eureka/ #开放端口 ports: - \"1430:1430\" #网络连接模式 network_mode: \"bridge\" supervise: image: 192.168.1.2:5000/test/supervise-svc:0.0.1-SNAPSHOT build: /opt/dockerfile/supervise-svc restart: always environment: defaultZone: http://192.168.1.3:1200/eureka/ ports: - \"1570:1570\" network_mode: \"bridge\" 常用命令 docker-copmpose build #打包镜像，后面不加项目名则打包所有配置了build的项目，可接多个项目名，用空格隔开 docker-compose up -d #后台运行项目，寻找本地镜像生成容器（若镜像更新则重启用新镜像生成容器），或者docker-compose.yml文件改变了也会进行更新容器，同样不接项目名为所有项目，也可以接多个项目名 docker-compose logs -f #查看日志，同上可接项目名 docker-compose pull #拉取镜像，同上可接项目名 docker-compose restart #重启容器，同上 docker-compose stop #停止运行容器，同上 实际生产环境部署项目/opt/dockerfile文件夹下是每个项目的目录，每个目录下是一个Dockerfile配置文件+打包的项目文件（java为.jar, react为tar.gz, 视项目和配置文件而定） /opt/cloud目录下是分的几个类，把几个项目归为一起，项目下是docker-compose.yml配置文件 以后端java项目meeting-svc为例 打包项目为jar包， 将jar包放在/opt/dockerfile/meeting-svc目录下 进入到/opt/cloud/service 运行指令docker-compose build meeting(配置文件中配置的项目名为meeting)打包镜像 运行docker-compose up -d meeting更新容器并运行 用docker-compose logs -f meeting进行查看日志 ps： 后端打包为tar -zcvf xxx.tar.gz -C dist/ . #dist为编译文件目录","categories":[{"name":"docker","slug":"docker","permalink":"https://www.kurenai.club/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.kurenai.club/tags/docker/"},{"name":"ops","slug":"ops","permalink":"https://www.kurenai.club/tags/ops/"}]},{"title":"Nginx基础——Rewrite规则","slug":"Nginx基础——Rewrite规则","date":"2018-12-30T15:13:00.000Z","updated":"2021-03-24T09:05:14.866Z","comments":true,"path":"2018/12/30/Nginx基础——Rewrite规则/","link":"","permalink":"https://www.kurenai.club/2018/12/30/Nginx基础——Rewrite规则/","excerpt":"&emsp;&emsp;rewrite是nginx一个特别重要的指令，该指令可以使用正则表达式改写URI。可以指定一个或多个rewrite指令，按顺序匹配。","text":"&emsp;&emsp;rewrite是nginx一个特别重要的指令，该指令可以使用正则表达式改写URI。可以指定一个或多个rewrite指令，按顺序匹配。 正则匹配规则~ 区分大小写匹配* 不区分大小写匹配! 和 !~* 区分大小写不匹配及不区分大小写不匹配 文件及目录匹配-f和!-f 判断是否存在文件-d和!-d 判断是否存在目录-e和!-e 判断是否存在文件或目录-x和!-x 判断文件是否可执行 rewrite基本语法set if return break rewrite break指令使用范围：server，location，if; 中断当前相同作用域的其他nginx配置。 if指令使用范围：server，location 检查一个条件是否符合。If指令不支持嵌套，不支持多个条件&amp;&amp;和||处理。 return指令格式：return code ;使用范围：server，location，if; 结束规则的执行并返回状态码给客户端。 set指令使用环境：server，location，if 定义一个变量，并给变量赋值。变量的值可以为文本、变量或者变量的组合。 set $var \"hello world\" rewrite指令格式rewrite regex replacement [flag]flag标志位有四种： break：停止rewrite检测,也就是说当含有break flag的rewrite语句被执行时,该语句就是rewrite的最终结果。last：停止rewrite检测,但是跟break有本质的不同,last的语句不一定是最终结果。redirect：返回302临时重定向，一般用于重定向到完整的URL(包含http:部分)permanent：返回301永久重定向，一般用于重定向到完整的URL(包含http:部分) 应用实例当访问的文件和目录不存在时，重定向到某个php文件 if( !-e $request_filename ) &#123; rewrite ^/(.*)$ index.php last; &#125; 目录对换 /123456/xxxx ====&gt; /xxxx?id=123456 rewrite ^/(\\d+)/(.+)/ /$2?id=$1 last; 如果客户端使用的是IE浏览器，则重定向到/ie目录下 if( $http_user_agent ~ MSIE) &#123; rewrite ^(.*)$ /ie/$1 break; &#125; 禁止访问以/data开头的文件 location ~ ^/data &#123; deny all; &#125; 禁止访问以.sh，.flv，.mp3为文件后缀名的文件 location ~ .*\\.(sh|flv|mp3)$ &#123; return 403; &#125; 设置某些类型文件的浏览器缓存时间 location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 30d; &#125; 文件反盗链并设置过期时间 location ~*^.+\\.(jpg|jpeg|gif|png|swf|rar|zip|css|js)$ &#123; valid_referers none blocked *.linuxidc.com*.linuxidc.net localhost 208.97.167.194; if ($invalid_referer) &#123; rewrite ^/ http://img.linuxidc.net/leech.gif; return 412; break; &#125; access_log off; root /opt/lampp/htdocs/web; expires 3d; break; &#125; 将多级目录下的文件转成一个文件，增强seo效果 /job-123-456-789.html 指向/job/123/456/789.html rewrite^/job-([0-9]+)-([0-9]+)-([0-9]+)\\.html$ /job/$1/$2/jobshow_$3.html last; 域名跳转 server &#123; listen 80; server_name jump.linuxidc.com; index index.html index.htm index.php; root /opt/lampp/htdocs/www; rewrite ^/ http://www.linuxidc.com/; access_log off; &#125; 多域名转向 server_name www.linuxidc.comwww.linuxidc.net; index index.html index.htm index.php; root /opt/lampp/htdocs; if ($host ~ \"linuxidc\\.net\") &#123; rewrite ^(.*) http://www.linuxidc.com$1permanent; &#125;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.kurenai.club/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.kurenai.club/tags/Nginx/"},{"name":"转载","slug":"转载","permalink":"https://www.kurenai.club/tags/转载/"}]},{"title":"とある三秋 缒の摘抄","slug":"とある三秋 缒的一些摘抄","date":"2017-05-20T00:00:00.000Z","updated":"2021-03-24T09:05:14.866Z","comments":true,"path":"2017/05/20/とある三秋 缒的一些摘抄/","link":"","permalink":"https://www.kurenai.club/2017/05/20/とある三秋 缒的一些摘抄/","excerpt":"记录一下比较打动我的一些段落","text":"记录一下比较打动我的一些段落 后记&emsp;&emsp;这世上到处都有地洞，至少世界看在我眼里就是这样。有的洞小，有的洞大；有的洞浅，有的洞深；有的洞很明显，有的洞不明显；有的洞尚有人掉进去，有的洞已经有许多人掉进去。真的是五花八门。一旦想着这一个个地洞，就会让我满心不安，一步都不想动了。&emsp;&emsp;孩提时代，我喜欢那种会让我忘记地洞存在的故事。看来不只是我，大家都喜欢看那种书中世界的所有地洞都已经加盖的故事，也不知道是不是该叫“杀菌过的故事”。当然主角不会只遇到好事，经历的各种痛苦与难受的体验也不会比别人少，但最终来说，这一切都将成为他成长的动力，让读者可以沉浸在“人就是要接受一切勇敢活下去”这种可靠的感觉中。我说的就是这种故事。&emsp;&emsp;我想我们一定是不希望连在虚构的世界都要经历悲伤&emsp;&emsp;可是有一天，我发现自己不知不觉地身在阴暗的地洞中。那是一种没有任何前兆、没有天理可言的失足。由于那是个非常小且不起眼的地洞，很难指望会有别人帮助。所幸这个地洞并不是深到爬不出来，我花了很长时间，靠自己的力量终于脱身。&emsp;&emsp;来到地上后，我沐浴在久违的温暖阳光与清澈的徐风中，因而产生这样的想法。无论多么小心，都没有人知道何时会掉进地洞。这个世界就是这样的地方。下次我说不定会掉进一个更深的洞，深得让我再也回不到地面上。到时候，我该怎么办呢？&emsp;&emsp;从此之后，我就再也无法怀着以往那样单纯的心情，去看待那些“把地洞加了盖的故事”。相对地，我开始喜欢描写“在地洞里过的好像很幸福的人”的故事。因为我想听的是在阴暗、深邃、狭窄又寒冷的地洞里，不用逞强也能露出微笑的人身上所发生的故事。也许对现在的我来说，再也没有什么比这个更能安慰我了。 三秋 缒いたいのいたいの、とんでゆけ","categories":[],"tags":[{"name":"三秋 缒","slug":"三秋-缒","permalink":"https://www.kurenai.club/tags/三秋-缒/"},{"name":"摘抄","slug":"摘抄","permalink":"https://www.kurenai.club/tags/摘抄/"},{"name":"小说","slug":"小说","permalink":"https://www.kurenai.club/tags/小说/"}]},{"title":"Test","slug":"Demo","date":"2017-04-20T00:00:00.000Z","updated":"2021-03-24T09:05:14.858Z","comments":true,"path":"2017/04/20/Demo/","link":"","permalink":"https://www.kurenai.club/2017/04/20/Demo/","excerpt":"test test！！","text":"test test！！ ACG格子裙赛高！ カントク - COLORS(id=47646872)","categories":[{"name":"ACG","slug":"ACG","permalink":"https://www.kurenai.club/categories/ACG/"}],"tags":[{"name":"监督","slug":"监督","permalink":"https://www.kurenai.club/tags/监督/"},{"name":"格子裙","slug":"格子裙","permalink":"https://www.kurenai.club/tags/格子裙/"},{"name":"放学五年目","slug":"放学五年目","permalink":"https://www.kurenai.club/tags/放学五年目/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-20T00:00:00.000Z","updated":"2021-03-24T09:05:14.866Z","comments":true,"path":"2017/03/20/hello-world/","link":"","permalink":"https://www.kurenai.club/2017/03/20/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"tags","slug":"tags","permalink":"https://www.kurenai.club/tags/tags/"}]}],"categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.kurenai.club/categories/Redis/"},{"name":"Java","slug":"Java","permalink":"https://www.kurenai.club/categories/Java/"},{"name":"Reactor","slug":"Java/Reactor","permalink":"https://www.kurenai.club/categories/Java/Reactor/"},{"name":"docker","slug":"docker","permalink":"https://www.kurenai.club/categories/docker/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.kurenai.club/categories/Nginx/"},{"name":"ACG","slug":"ACG","permalink":"https://www.kurenai.club/categories/ACG/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.kurenai.club/tags/Java/"},{"name":"ORM","slug":"ORM","permalink":"https://www.kurenai.club/tags/ORM/"},{"name":"JPA","slug":"JPA","permalink":"https://www.kurenai.club/tags/JPA/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://www.kurenai.club/tags/Hibernate/"},{"name":"Reactor","slug":"Reactor","permalink":"https://www.kurenai.club/tags/Reactor/"},{"name":"Webflux","slug":"Webflux","permalink":"https://www.kurenai.club/tags/Webflux/"},{"name":"Spring","slug":"Spring","permalink":"https://www.kurenai.club/tags/Spring/"},{"name":"DDD","slug":"DDD","permalink":"https://www.kurenai.club/tags/DDD/"},{"name":"CQRS","slug":"CQRS","permalink":"https://www.kurenai.club/tags/CQRS/"},{"name":"Event Sourcing","slug":"Event-Sourcing","permalink":"https://www.kurenai.club/tags/Event-Sourcing/"},{"name":"docker","slug":"docker","permalink":"https://www.kurenai.club/tags/docker/"},{"name":"ops","slug":"ops","permalink":"https://www.kurenai.club/tags/ops/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.kurenai.club/tags/Nginx/"},{"name":"转载","slug":"转载","permalink":"https://www.kurenai.club/tags/转载/"},{"name":"三秋 缒","slug":"三秋-缒","permalink":"https://www.kurenai.club/tags/三秋-缒/"},{"name":"摘抄","slug":"摘抄","permalink":"https://www.kurenai.club/tags/摘抄/"},{"name":"小说","slug":"小说","permalink":"https://www.kurenai.club/tags/小说/"},{"name":"监督","slug":"监督","permalink":"https://www.kurenai.club/tags/监督/"},{"name":"格子裙","slug":"格子裙","permalink":"https://www.kurenai.club/tags/格子裙/"},{"name":"放学五年目","slug":"放学五年目","permalink":"https://www.kurenai.club/tags/放学五年目/"},{"name":"tags","slug":"tags","permalink":"https://www.kurenai.club/tags/tags/"}]}