{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"About","text":"具有反女生立场的家养宅男一只 :) Programmer ACGer 声豚 马场木实P 松冈爱衣催婚委员会会员 山田エルフは俺の嫁！！！！","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Test","text":"test test！！ ACG格子裙赛高！ カントク - COLORS(id=47646872)","link":"/2017/04/20/Demo/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2017/03/20/hello-world/"},{"title":"とある三秋 缒の摘抄","text":"记录一下比较打动我的一些段落后记&emsp;&emsp;这世上到处都有地洞，至少世界看在我眼里就是这样。有的洞小，有的洞大；有的洞浅，有的洞深；有的洞很明显，有的洞不明显；有的洞尚有人掉进去，有的洞已经有许多人掉进去。真的是五花八门。一旦想着这一个个地洞，就会让我满心不安，一步都不想动了。&emsp;&emsp;孩提时代，我喜欢那种会让我忘记地洞存在的故事。看来不只是我，大家都喜欢看那种书中世界的所有地洞都已经加盖的故事，也不知道是不是该叫“杀菌过的故事”。当然主角不会只遇到好事，经历的各种痛苦与难受的体验也不会比别人少，但最终来说，这一切都将成为他成长的动力，让读者可以沉浸在“人就是要接受一切勇敢活下去”这种可靠的感觉中。我说的就是这种故事。&emsp;&emsp;我想我们一定是不希望连在虚构的世界都要经历悲伤&emsp;&emsp;可是有一天，我发现自己不知不觉地身在阴暗的地洞中。那是一种没有任何前兆、没有天理可言的失足。由于那是个非常小且不起眼的地洞，很难指望会有别人帮助。所幸这个地洞并不是深到爬不出来，我花了很长时间，靠自己的力量终于脱身。&emsp;&emsp;来到地上后，我沐浴在久违的温暖阳光与清澈的徐风中，因而产生这样的想法。无论多么小心，都没有人知道何时会掉进地洞。这个世界就是这样的地方。下次我说不定会掉进一个更深的洞，深得让我再也回不到地面上。到时候，我该怎么办呢？&emsp;&emsp;从此之后，我就再也无法怀着以往那样单纯的心情，去看待那些“把地洞加了盖的故事”。相对地，我开始喜欢描写“在地洞里过的好像很幸福的人”的故事。因为我想听的是在阴暗、深邃、狭窄又寒冷的地洞里，不用逞强也能露出微笑的人身上所发生的故事。也许对现在的我来说，再也没有什么比这个更能安慰我了。 三秋 缒いたいのいたいの、とんでゆけ","link":"/2017/05/20/とある三秋 缒的一些摘抄/"},{"title":"将项目部署在docker中","text":"docker中有两个概念，容器与镜像。 镜像我们可以简单的理解为是装机用的光盘，而容器就是我们用光盘所装的一个系统。实际上我们就是由镜像生成一个容器，一个镜像可以生成多个容器（只要容器互不相冲突）。 而镜像的生成就是由配置文件来决定（配置文件参数可由后期运行指令等等操作更改），具体如何配置不详细说明。 Banner: カントク - COLORS 配置文件例子Dockerfile123456789101112131415161718192021#后端java项目#基础镜像FROM 192.168.1.2:5000/library/centos-jdk:1.7.79#作者MAINTAINER kurenai kurenai@moe.com#执行命令，主要用来安装相关的软件#RUN #添加文件ADD target/supervise-svc-0.0.1-SNAPSHOT.jar /usr/localRUN chmod u+x /usr/local/supervise-svc-0.0.1-SNAPSHOT.jar#挂载目录到容器#VOLUME [\"/data\"]#环境变量设置#ENV #开放端口EXPOSE 1234#启动时执行的命令CMD [\"/bin/bash\"]#启动时执行的命令ENTRYPOINT [\"java\",\"-jar\",\"-Xms2048m\", \"-Xmx2048m\", \"-XX:PermSize=256M\", \"-XX:MaxPermSize=256M\",\"/usr/local/supervise-svc-0.0.1-SNAPSHOT.jar\"] 123456789101112131415161718192021222324#前端react项目#基础镜像FROM xxx.xxx.com:5000/library/ui-nginx:latest#维护人信息MAINTAINER WenboLI liwenbo@ly-sky.com#工作目录WORKDIR /usr/local/nginxADD ui.tar.gz /usr/local/nginx/html/ADD nginx.conf /usr/local/nginx/conf/#暴露端口EXPOSE 80#连接时执行的命令CMD [\"/bin/bash\"]#启动时执行的命令#ENTRYPOINT nginx -g \"daemon off;\"ENTRYPOINT /opt/run.sh 基础命令 123456789docker ps #查看doker中正在运行的容器列表docker images #查看docker中的镜像列表docker build #将当前目录下的文件打包为镜像docker rm #移除容器docker rmi #移除镜像docker pull #拉取镜像docker logs -f #查看日志docker restart #重启容器docker stop #停止容器运行 docker-compose能够比较集中的管理镜像和容器的部署问题，不必用像原生docker那样一个一个项目进行打包镜像生成容器，只需要把n个项目的配置写在配置文件中即可进行批量打包，拉取镜像，生成容器 配置文件例子docker-compose.yml 123456789101112131415161718192021222324252627version: '2.2'services: #项目名称，用docker-compose做管理时，每个项目用这里配置的名称进行单独管理 base: #镜像名，拉取镜像时也是用这个名字作为地址 image: 192.168.1.2:5000/test/base-svc:0.0.1-SNAPSHOT #打包路径，即docker build的路径 build: /opt/dockerfile/base-svc restart: always #环境变量 environment: defaultZone: http://192.168.1.3:1200/eureka/ #开放端口 ports: - \"1430:1430\" #网络连接模式 network_mode: \"bridge\" supervise: image: 192.168.1.2:5000/test/supervise-svc:0.0.1-SNAPSHOT build: /opt/dockerfile/supervise-svc restart: always environment: defaultZone: http://192.168.1.3:1200/eureka/ ports: - \"1570:1570\" network_mode: \"bridge\" 常用命令 123456docker-copmpose build #打包镜像，后面不加项目名则打包所有配置了build的项目，可接多个项目名，用空格隔开docker-compose up -d #后台运行项目，寻找本地镜像生成容器（若镜像更新则重启用新镜像生成容器），或者docker-compose.yml文件改变了也会进行更新容器，同样不接项目名为所有项目，也可以接多个项目名docker-compose logs -f #查看日志，同上可接项目名docker-compose pull #拉取镜像，同上可接项目名docker-compose restart #重启容器，同上docker-compose stop #停止运行容器，同上 实际生产环境部署项目/opt/dockerfile文件夹下是每个项目的目录，每个目录下是一个Dockerfile配置文件+打包的项目文件（java为.jar, react为tar.gz, 视项目和配置文件而定） /opt/cloud目录下是分的几个类，把几个项目归为一起，项目下是docker-compose.yml配置文件 以后端java项目meeting-svc为例 打包项目为jar包， 将jar包放在/opt/dockerfile/meeting-svc目录下 进入到/opt/cloud/service 运行指令docker-compose build meeting(配置文件中配置的项目名为meeting)打包镜像 运行docker-compose up -d meeting更新容器并运行 用docker-compose logs -f meeting进行查看日志 ps： 后端打包为tar -zcvf xxx.tar.gz -C dist/ . #dist为编译文件目录","link":"/2019/03/14/将项目部署在docker中/"},{"title":"Nginx基础——Rewrite规则","text":"&emsp;&emsp;rewrite是nginx一个特别重要的指令，该指令可以使用正则表达式改写URI。可以指定一个或多个rewrite指令，按顺序匹配。 正则匹配规则~ 区分大小写匹配~ 不区分大小写匹配!~ 和 !~ 区分大小写不匹配及不区分大小写不匹配 文件及目录匹配-f和!-f 判断是否存在文件-d和!-d 判断是否存在目录-e和!-e 判断是否存在文件或目录-x和!-x 判断文件是否可执行 rewrite基本语法12345set if returnbreakrewrite break指令使用范围：server，location，if; 中断当前相同作用域的其他nginx配置。 if指令使用范围：server，location 检查一个条件是否符合。If指令不支持嵌套，不支持多个条件&amp;&amp;和||处理。 return指令格式：return code ;使用范围：server，location，if; 结束规则的执行并返回状态码给客户端。 set指令使用环境：server，location，if 定义一个变量，并给变量赋值。变量的值可以为文本、变量或者变量的组合。1set $var \"hello world\" rewrite指令格式rewrite regex replacement [flag] flag标志位有四种：break：停止rewrite检测,也就是说当含有break flag的rewrite语句被执行时,该语句就是rewrite的最终结果。last：停止rewrite检测,但是跟break有本质的不同,last的语句不一定是最终结果。redirect：返回302临时重定向，一般用于重定向到完整的URL(包含http:部分)permanent：返回301永久重定向，一般用于重定向到完整的URL(包含http:部分) 应用实例当访问的文件和目录不存在时，重定向到某个php文件 1234if( !-e $request_filename ){ rewrite ^/(.*)$ index.php last;} 目录对换 /123456/xxxx ====&gt; /xxxx?id=123456 1rewrite ^/(\\d+)/(.+)/ /$2?id=$1 last; 如果客户端使用的是IE浏览器，则重定向到/ie目录下 1234if( $http_user_agent ~ MSIE){ rewrite ^(.*)$ /ie/$1 break;} 禁止访问以/data开头的文件 1234location ~ ^/data{ deny all;} 禁止访问以.sh，.flv，.mp3为文件后缀名的文件 1234location ~ .*\\.(sh|flv|mp3)${ return 403;} 设置某些类型文件的浏览器缓存时间 1234location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)${ expires 30d;} 文件反盗链并设置过期时间 12345678910111213location ~*^.+\\.(jpg|jpeg|gif|png|swf|rar|zip|css|js)$ { valid_referers none blocked *.linuxidc.com*.linuxidc.net localhost 208.97.167.194; if ($invalid_referer) { rewrite ^/ http://img.linuxidc.net/leech.gif; return 412; break; } access_log off; root /opt/lampp/htdocs/web; expires 3d; break;} 将多级目录下的文件转成一个文件，增强seo效果 1234 /job-123-456-789.html 指向/job/123/456/789.htmlrewrite^/job-([0-9]+)-([0-9]+)-([0-9]+)\\.html$ /job/$1/$2/jobshow_$3.html last; 域名跳转 123456789server{ listen 80; server_name jump.linuxidc.com; index index.html index.htm index.php; root /opt/lampp/htdocs/www; rewrite ^/ http://www.linuxidc.com/; access_log off;} 多域名转向 123456server_name www.linuxidc.comwww.linuxidc.net;index index.html index.htm index.php;root /opt/lampp/htdocs;if ($host ~ &quot;linuxidc\\.net&quot;) { rewrite ^(.*) http://www.linuxidc.com$1permanent;}","link":"/2018/12/30/Nginx基础——Rewrite规则/"},{"title":"Re：从零开始的领域驱动设计","text":"领域驱动设计(Domain-driven design)，缩写为DDD。以领域设计为驱动，构建整一个系统。 这个设计思想是在微服务开始流行时逐渐变得火爆的，因为其设计理念非常适合分布式的微服务拆分。 我声明一点，本文章其实都是东拼西凑的，里面所表达的仅仅是个人的理解（我没有读完ddd那本书） 通用语言(Ubiquitous Language)通用语言其实就是把模型通过大家都能够理解的语言表达出来。 通常我们在开发业务的过程中都是先去调研，了解其业务的具体细节，并商讨大致的程序设计，然后经过开发人员转化成为代码，在这个过程中交流是单向性的，直到下一次需要展示或者有理解出现错误时才会与客户或者是业务人员再次交流。 而业务人员那边通常也只能通过表面的程序看问题，无法理解其实际运作是否符合业务人员所想，这可能将导致程序在错误的方向上越走越远 领域驱动设计是需要建立一个通用语言的，这需要领域专家(即对这些业务整体非常熟悉的人)与开发人员一同参与 我们需要把程序设计上的事情通过一个通用的语言表述出去使领域专家能够理解我们是如何通过程序设计业务的，而领域专家也同样需要把那些专业名词，业务场景用通用语言描述出来 当我们有了通用语言后，我们就能够在建立领域对象的时候听取专家的意见，同时能够让专家理解领域对象是否符合他们的预期 而形成通用语言是不容易的，因为其答案并不唯一，不同的人会有不同的理解，从而导致不同的答案。但我们可以试着从UML或是伪代码着手 层结构(Layered Architecture) User Interface负责向用户展现信息，并且会解析用户行为，即常说的展现层。 Application Layer应用层没有任何的业务逻辑代码，它很简单，它主要为程序提供任务处理。 Domain Layer这一层包含有关领域的信息，是业务的核心，领域模型的状态都直接或间接（持久化至数据库）存储在这一层。 Infrastructure Layer为其他层提供底层依赖操作。 模型关系图(Model-Driven Design) 服务(Services)当我们在分析某一领域时，一直在尝试如何将信息转化为领域模型，但并非所有的点我们都能用Model来涵盖。对象应当有属性，状态和行为，但有时领域中有一些行为是无法映射到具体的对象中的，我们也不能强行将其放入在某一个模型对象中，而将其单独作为一个方法又没有地方，此时就需要服务 工厂(Factories)在大型系统中，实体和聚合通常是很复杂的，这就导致了很难去通过构造器来创建对象。工厂就决解了这个问题，它把创建对象的细节封装起来，巧妙的实现了依赖反转。当然对聚合也适用（当建立了聚合根时，其他对象可以自动创建） 仓库(Repository)仓库封装了获取对象的逻辑，领域对象无须和底层数据库交互，它只需要从仓库中获取对象即可。仓库可以存储对象的引用，当一个对象被创建后，它可能会被存储到仓库中，那么下次就可以从仓库取。如果用户请求的数据没在仓库中，则会从数据库里取，这就减少了底层交互的次数 边界上下文(Bounded Context)简单来说就是定义该领域模型的适用范围以及使用场景。 可以这样理解： 边界(Bounded)即有边界的，表示领域模型有边界；这个边界定义了模型的适用范围，以便让负责该模型的团队知道什么该在模型中实现，什么不该； 上下文(Context)即领域模型的产生是在某个上下文中产生的；上下文是一个和环境相关的概念。比如一次头脑风暴会议大家达成了一个模型，那这次会议的讨论就是该模型的上下文；比如某本书中谈到了某个东西，那这个东西的上下文就是那本书，那个东西要有意义的前提离不开那本书这个上下文；所以，上下文是模型有意义的前提； 实体(Entity) 和 值对象(ValueObject)一言蔽之，实体大致可以理解为我们传统开发的实体，但是他具有自己的行为，而不是POJO(只具有简单的getter,setter)；值对象是指描述一个实体某个属性的对象。当然，这些都是需要在上面所说的BoundedContext被指定的前提下讨论。 举个例子：在电商系统我们现在分成两个模块，一个商品模块，一个订单模块订单对象中有收货地址(address)1234Order { int id; String address; } 我们把address扩展开来12345678910Order { int id; Address address; }Address { String province;//省 String city;//市 String street;//街道} 现在Address是一个对象了，但是我们不会认为他是一个实体，因为在这个订单模块中它只是描述了订单中的收货地址而已，仅仅只是order上的一个值，几个内部的值所组合出的抽象，你完全可以把它理解为是一个Map:123456Order { int id; Map&lt;String, String&gt; address; //address Map{&quot;province&quot;:&quot;&quot;,&quot;city&quot;:&quot;&quot;,&quot;street&quot;:&quot;&quot;} } 这跟java中String对象非常类似，String对象是不会进行修改的，如果你将新的一串字符串重新赋值给一个String对象，实际上等于new了一个String，地址是变化了的，不再是同一个对象。 所以ValueObject有这样几个特点: 没有标识(唯一标识) 不可变(只读) 不具备生命周期 聚合(Aggregates) 和 聚合(Aggregate Root)聚合可以看作是多个实体之间的组合，而每个聚合都有一个根实体，叫聚合根。 在DDD当中，聚合外部想要访问聚合内的信息，必须通过聚合根进行访问。 如何识别聚合和聚合根？首先一个边界上下文(Bounded Context)可能包含多个聚合，每个聚合都有一个聚合根。 找出哪些实体可能是聚合根 逐个分析每个聚合根的边界，即该聚合根应该聚合哪些实体或值对象 划分边界上下文 如何确定聚合边界？边界的确定法则是根据不变性约束规则（Invariant）: 聚合边界内必须具有哪些信息，如果没有这些信息就不能称为一个有效的聚合 聚合内的某些对象的状态必须满足某个业务规则 如何找到聚合根？如果存在一个业务操作是完全面向某个实体，那么这个实体就可能是一个聚合根 例子分析 Order（一 个订单）必须有对应的客户信息，否则就不能称为一个有效的Order同理，Order对OrderLineItem有不变性约束，Order也必须至少有一个OrderLineItem(一条订单明细)，否则就不能称为一个有效的Order另外，Order中的任何OrderLineItem的数量都不能为0，否则认为该OrderLineItem是无效的，同时可以推理出Order也可能是无效的。因为如果允许一个OrderLineItem的数量为0的话，就意味着可能会出现所有OrderLineItem的数量都为0，这就导致整个Order的总价为0，这是没有任何意义的，是不允许的，从而导致Order无效所以，必须要求 Order中所有的OrderLineItem的数量都不能为0那么现在可以确定的是Order必须包含一些OrderLineItem，那么应该是通 过引用的方式还是ID关联的方式来表达这种包含关系呢？这就需要引出另外一个问题，那就是先要分析出是OrderLineItem是否是一个独立的聚合根。回答了这个问题，那么根据上面的规则就知道应该用对象引用还是用ID关联了。那么OrderLineItem是否是一个独立的聚合根呢？因为聚合根意 味着是某个聚合的根，而聚合有代表着某个上下文边界，而一个上下文边界又代表着某个独立的业务场景，这个业务场景操作的唯一对象总是该上下文边界内的聚合 根。想到这里，我们就可以想想，有没有什么场景是会绕开订单直接对某个订单明细进行操作的。也就是在这种情况下，我们 是以OrderLineItem为主体，完全是在面向OrderLineItem在做业务操作。有这种业务场景吗？没有，我们对 OrderLineItem的所有的操作都是以Order为出发点，我们总是会面向整个Order在做业务操作，比如向Order中增加明细，修改 Order的某个明细对应的商品的购买数量，从Order中移除某个明细，等等类似操作，我们从来不会从OrderlineItem为出发点去执行一些业 务操作；另外，从生命周期的角度去理解，那么OrderLineItem离开Order没有任何存在的意义，也就是说OrderLineItem的生命周 期是从属于Order的。所以，我们可以很确信的回答，OrderLineItem是一个实体。 Event Souring(事件溯源) CQRS(命令查询责任分离)CQRS","link":"/2019/08/11/DDD/"}],"tags":[{"name":"监督","slug":"监督","link":"/tags/监督/"},{"name":"格子裙","slug":"格子裙","link":"/tags/格子裙/"},{"name":"放学五年目","slug":"放学五年目","link":"/tags/放学五年目/"},{"name":"tags","slug":"tags","link":"/tags/tags/"},{"name":"三秋 缒","slug":"三秋-缒","link":"/tags/三秋-缒/"},{"name":"摘抄","slug":"摘抄","link":"/tags/摘抄/"},{"name":"小说","slug":"小说","link":"/tags/小说/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"ops","slug":"ops","link":"/tags/ops/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"转载","slug":"转载","link":"/tags/转载/"},{"name":"DDD","slug":"DDD","link":"/tags/DDD/"},{"name":"CQRS","slug":"CQRS","link":"/tags/CQRS/"},{"name":"Event Sourcing","slug":"Event-Sourcing","link":"/tags/Event-Sourcing/"}],"categories":[{"name":"ACG","slug":"ACG","link":"/categories/ACG/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"Nginx","slug":"Nginx","link":"/categories/Nginx/"},{"name":"Coding","slug":"Coding","link":"/categories/Coding/"}]}