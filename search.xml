<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Re：从零开始的领域驱动设计</title>
    <url>/2019/08/11/DDD/</url>
    <content><![CDATA[<p>领域驱动设计(Domain-driven design)，缩写为DDD。以领域设计为驱动，构建整一个系统。</p>
<p>这个设计思想是在微服务开始流行时逐渐变得火爆的，因为其设计理念非常适合分布式的微服务拆分。</p>
<a id="more"></a>

<blockquote>
<p>我声明一点，本文章其实都是东拼西凑的，里面所表达的仅仅是个人的理解（我没有读完ddd那本书）</p>
</blockquote>
<h1 id="通用语言-Ubiquitous-Language"><a href="#通用语言-Ubiquitous-Language" class="headerlink" title="通用语言(Ubiquitous Language)"></a>通用语言(Ubiquitous Language)</h1><p>通用语言其实就是把模型通过大家都能够理解的语言表达出来。</p>
<p>通常我们在开发业务的过程中都是先去调研，了解其业务的具体细节，并商讨大致的程序设计，然后经过开发人员转化成为代码，在这个过程中交流是单向性的，直到下一次需要展示或者有理解出现错误时才会与客户或者是业务人员再次交流。</p>
<p>而业务人员那边通常也只能通过表面的程序看问题，无法理解其实际运作是否符合业务人员所想，这可能将导致程序在错误的方向上越走越远</p>
<p>领域驱动设计是需要建立一个通用语言的，这需要领域专家(即对这些业务整体非常熟悉的人)与开发人员一同参与</p>
<p>我们需要把程序设计上的事情通过一个通用的语言表述出去使领域专家能够理解我们是如何通过程序设计业务的，而领域专家也同样需要把那些专业名词，业务场景用通用语言描述出来</p>
<p>当我们有了通用语言后，我们就能够在建立领域对象的时候听取专家的意见，同时能够让专家理解领域对象是否符合他们的预期  </p>
<p>而形成通用语言是不容易的，因为其答案并不唯一，不同的人会有不同的理解，从而导致不同的答案。但我们可以试着从UML或是伪代码着手</p>
<p><a href="http://note.youdao.com/noteshare?id=3834bfbae566164a48b0df825fc8134d&sub=B24036AF24534B79875E2C0B5D4C886F" target="_blank" rel="noopener">航运例子</a></p>
<h1 id="层结构-Layered-Architecture"><a href="#层结构-Layered-Architecture" class="headerlink" title="层结构(Layered Architecture)"></a>层结构(Layered Architecture)</h1><p><img src="/2019/08/11/DDD/p29.png" srcset="/img/loading.gif" alt="Layered Architecture"></p>
<ul>
<li>User Interface<br>负责向用户展现信息，并且会解析用户行为，即常说的展现层。</li>
<li>Application Layer<br>应用层没有任何的业务逻辑代码，它很简单，它主要为程序提供任务处理。</li>
<li>Domain Layer<br>这一层包含有关领域的信息，是业务的核心，领域模型的状态都直接或间接（持久化至数据库）存储在这一层。</li>
<li>Infrastructure Layer<br>为其他层提供底层依赖操作。</li>
</ul>
<h1 id="模型关系图-Model-Driven-Design"><a href="#模型关系图-Model-Driven-Design" class="headerlink" title="模型关系图(Model-Driven Design)"></a>模型关系图(Model-Driven Design)</h1><p><img src="/2019/08/11/DDD/p28.png" srcset="/img/loading.gif" alt="Model-Driven Design"></p>
<h2 id="服务-Services"><a href="#服务-Services" class="headerlink" title="服务(Services)"></a>服务(Services)</h2><p>当我们在分析某一领域时，一直在尝试如何将信息转化为领域模型，但并非所有的点我们都能用Model来涵盖。对象应当有属性，状态和行为，但有时领域中有一些行为是无法映射到具体的对象中的，我们也不能强行将其放入在某一个模型对象中，而将其单独作为一个方法又没有地方，此时就需要服务</p>
<h2 id="工厂-Factories"><a href="#工厂-Factories" class="headerlink" title="工厂(Factories)"></a>工厂(Factories)</h2><p>在大型系统中，实体和聚合通常是很复杂的，这就导致了很难去通过构造器来创建对象。工厂就决解了这个问题，它把创建对象的细节封装起来，巧妙的实现了依赖反转。当然对聚合也适用（当建立了聚合根时，其他对象可以自动创建）</p>
<h2 id="仓库-Repository"><a href="#仓库-Repository" class="headerlink" title="仓库(Repository)"></a>仓库(Repository)</h2><p>仓库封装了获取对象的逻辑，领域对象无须和底层数据库交互，它只需要从仓库中获取对象即可。仓库可以存储对象的引用，当一个对象被创建后，它可能会被存储到仓库中，那么下次就可以从仓库取。如果用户请求的数据没在仓库中，则会从数据库里取，这就减少了底层交互的次数</p>
<h2 id="边界上下文-Bounded-Context"><a href="#边界上下文-Bounded-Context" class="headerlink" title="边界上下文(Bounded Context)"></a>边界上下文(Bounded Context)</h2><p>简单来说就是定义该领域模型的适用范围以及使用场景。</p>
<p>可以这样理解：</p>
<ul>
<li><p>边界(Bounded)<br>即有边界的，表示领域模型有边界；这个边界定义了模型的适用范围，以便让负责该模型的团队知道什么该在模型中实现，什么不该；</p>
</li>
<li><p>上下文(Context)<br>即领域模型的产生是在某个上下文中产生的；上下文是一个和环境相关的概念。比如一次头脑风暴会议大家达成了一个模型，那这次会议的讨论就是该模型的上下文；比如某本书中谈到了某个东西，那这个东西的上下文就是那本书，那个东西要有意义的前提离不开那本书这个上下文；所以，上下文是模型有意义的前提；</p>
</li>
</ul>
<h2 id="实体-Entity-和-值对象-ValueObject"><a href="#实体-Entity-和-值对象-ValueObject" class="headerlink" title="实体(Entity) 和 值对象(ValueObject)"></a>实体(Entity) 和 值对象(ValueObject)</h2><p>一言蔽之，实体大致可以理解为我们传统开发的实体，但是他具有自己的行为，而不是POJO(只具有简单的getter,setter)；值对象是指描述一个实体某个属性的对象。<br>当然，这些都是需要在上面所说的BoundedContext被指定的前提下讨论。</p>
<p>举个例子：<br>在电商系统我们现在分成两个模块，一个商品模块，一个订单模块<br>订单对象中有收货地址(address)</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span> </span>&#123;
    <span class="hljs-keyword">int</span> id;
    String address; 
&#125;</code></pre></div>

<p>我们把address扩展开来</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span> </span>&#123;
    <span class="hljs-keyword">int</span> id;
    Address address; 
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;
    String province;<span class="hljs-comment">//省</span>
    String city;<span class="hljs-comment">//市</span>
    String street;<span class="hljs-comment">//街道</span>
&#125;</code></pre></div>

<p>现在Address是一个对象了，但是我们不会认为他是一个实体，因为在这个订单模块中它只是描述了订单中的收货地址而已，仅仅只是order上的一个值，几个内部的值所组合出的抽象，你完全可以把它理解为是一个Map:</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span> </span>&#123;
    <span class="hljs-keyword">int</span> id;
    Map&lt;String, String&gt; address;
    
    <span class="hljs-comment">//address Map&#123;"province":"","city":"","street":""&#125; </span>
&#125;</code></pre></div>

<p>这跟java中String对象非常类似，String对象是不会进行修改的，如果你将新的一串字符串重新赋值给一个String对象，实际上等于new了一个String，地址是变化了的，不再是同一个对象。</p>
<p>所以ValueObject有这样几个特点:</p>
<ul>
<li>没有标识(唯一标识)</li>
<li>不可变(只读)</li>
<li>不具备生命周期</li>
</ul>
<h2 id="聚合-Aggregates-和-聚合-Aggregate-Root"><a href="#聚合-Aggregates-和-聚合-Aggregate-Root" class="headerlink" title="聚合(Aggregates) 和 聚合(Aggregate Root)"></a>聚合(Aggregates) 和 聚合(Aggregate Root)</h2><p><strong>聚合</strong>可以看作是多个实体之间的组合，而每个聚合都有一个根实体，叫<strong>聚合根</strong>。</p>
<p>在DDD当中，聚合外部想要访问聚合内的信息，必须通过<strong>聚合根</strong>进行访问。</p>
<ul>
<li><p>如何识别聚合和聚合根？<br>首先一个边界上下文(Bounded Context)可能包含多个聚合，每个聚合都有一个聚合根。</p>
<ol>
<li>找出哪些实体可能是聚合根</li>
<li>逐个分析每个聚合根的边界，即该聚合根应该聚合哪些实体或值对象</li>
<li>划分边界上下文</li>
</ol>
</li>
<li><p>如何确定聚合边界？<br>边界的确定法则是根据不变性约束规则（Invariant）:</p>
<ul>
<li>聚合边界内必须具有哪些信息，如果没有这些信息就不能称为一个有效的聚合</li>
<li>聚合内的某些对象的状态必须满足某个业务规则 </li>
</ul>
</li>
<li><p>如何找到聚合根？<br>如果存在一个业务操作是完全面向某个实体，那么这个实体就可能是一个聚合根</p>
</li>
</ul>
<h3 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h3><blockquote>
<p>Order（一 个订单）必须有对应的客户信息，否则就不能称为一个有效的Order<br>同理，Order对OrderLineItem有不变性约束，Order也必须至少有一个OrderLineItem(一条订单明细)，否则就不能称为一个有效的Order<br>另外，Order中的任何OrderLineItem的数量都不能为0，否则认为该OrderLineItem是无效的，同时可以推理出Order也可能是无效的。因为如果允许一个OrderLineItem的数量为0的话，就意味着可能会出现所有OrderLineItem的数量都为0，这就导致整个Order的总价为0，这是没有任何意义的，是不允许的，从而导致Order无效<br>所以，必须要求 Order中所有的OrderLineItem的数量都不能为0<br>那么现在可以确定的是Order必须包含一些OrderLineItem，那么应该是通 过引用的方式还是ID关联的方式来表达这种包含关系呢？<br>这就需要引出另外一个问题，那就是先要分析出是OrderLineItem是否是一个独立的聚合根。<br>回答了这个问题，那么根据上面的规则就知道应该用对象引用还是用ID关联了。那么OrderLineItem是否是一个独立的聚合根呢？因为聚合根意 味着是某个聚合的根，而聚合有代表着某个上下文边界，而一个上下文边界又代表着某个独立的业务场景，这个业务场景操作的唯一对象总是该上下文边界内的聚合 根。想到这里，我们就可以想想，有没有什么场景是会绕开订单直接对某个订单明细进行操作的。也就是在这种情况下，我们 是以OrderLineItem为主体，完全是在面向OrderLineItem在做业务操作。有这种业务场景吗？没有，我们对 OrderLineItem的所有的操作都是以Order为出发点，我们总是会面向整个Order在做业务操作，比如向Order中增加明细，修改 Order的某个明细对应的商品的购买数量，从Order中移除某个明细，等等类似操作，我们从来不会从OrderlineItem为出发点去执行一些业 务操作；另外，从生命周期的角度去理解，那么OrderLineItem离开Order没有任何存在的意义，也就是说OrderLineItem的生命周 期是从属于Order的。所以，我们可以很确信的回答，OrderLineItem是一个实体。</p>
</blockquote>
<h1 id="Event-Souring-事件溯源"><a href="#Event-Souring-事件溯源" class="headerlink" title="Event Souring(事件溯源)"></a>Event Souring(事件溯源)</h1><p>Event Souring是Martin Fowler提出的一种架构模式，其特点是：</p>
<ul>
<li>整个系统由事件进行驱动</li>
<li>事件是一等公民，系统的基础数据是事件，事件需要被储存在数据库中</li>
<li>业务数据只是由事件产生的视图，不一定需要存储在数据库</li>
</ul>
<p>这里展示的例子是一个银行账户经历的几个事件：创建 -&gt; 存款300 -&gt; 存款100 -&gt; 取出200<br><img src="/2019/08/11/DDD/v2-7c6a1b0c101d8f0cf5e89716bfb4d6a1_hd.jpg" srcset="/img/loading.gif" alt="Event Souring"></p>
<p>在这样的设计下，每个对象都需要经历一系列的事件才会转化成现在的状态，当我们只需要进行查询的时候，这些操作未免显得太过累赘，所以我们可以把对象的最终状态存入一个视图数据库，当需要查询的时候直接查询这个数据库即可<br><img src="/2019/08/11/DDD/v2-35249fb2693f44bbe4bf48ea6755c55c_hd.jpg" srcset="/img/loading.gif" alt="Event Souring"></p>
<h1 id="CQRS-命令查询责任分离"><a href="#CQRS-命令查询责任分离" class="headerlink" title="CQRS(命令查询责任分离)"></a>CQRS(命令查询责任分离)</h1><p>CQRS简单理解就是读写分离，但它的实现可能相对其定义要复杂些，并且通常都是会和Event Souring一起被提及<br><img src="/2019/08/11/DDD/CQRS.jpg" srcset="/img/loading.gif" alt="CQRS + Event Souring"></p>
<p>参考资料：</p>
<ul>
<li>《领域驱动设计：软件核心复杂性应对之道》  </li>
<li><a href="https://zhuanlan.zhihu.com/p/38968012" target="_blank" rel="noopener">深入浅出Event Sourcing和CQRS</a></li>
<li><a href="https://www.cnkirito.moe/Re-DDD/" target="_blank" rel="noopener">Re：从零开始的领域驱动设计</a></li>
<li><a href="https://www.cnkirito.moe/DDD-practice/" target="_blank" rel="noopener">一个DDD指导下的实体类设计案例</a></li>
<li><a href="https://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html" target="_blank" rel="noopener">DDD领域驱动设计基本理论知识总结</a></li>
<li><a href="http://newtech.club/2017/06/09/%E5%A4%9A%E7%A0%94%E7%A9%B6%E4%BA%9B%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%B0%91%E8%B0%88%E4%BA%9B%E6%A1%86%E6%9E%B6%EF%BC%881%EF%BC%89-%E8%AE%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener">多研究些架构，少谈些框架</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>CQRS</tag>
        <tag>Event Sourcing</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx基础——Rewrite规则</title>
    <url>/2018/12/30/Nginx%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Rewrite%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>&emsp;&emsp;rewrite是nginx一个特别重要的指令，该指令可以使用正则表达式改写URI。可以指定一个或多个rewrite指令，按顺序匹配。</p>
<a id="more"></a>
<h2 id="正则匹配规则"><a href="#正则匹配规则" class="headerlink" title="正则匹配规则"></a>正则匹配规则</h2><blockquote><p>~  区分大小写匹配<br><del>* 不区分大小写匹配<br>!</del> 和 !~* 区分大小写不匹配及不区分大小写不匹配  </p>
</blockquote>

<h2 id="文件及目录匹配"><a href="#文件及目录匹配" class="headerlink" title="文件及目录匹配"></a>文件及目录匹配</h2><blockquote><p>-f和!-f 判断是否存在文件<br>-d和!-d 判断是否存在目录<br>-e和!-e 判断是否存在文件或目录<br>-x和!-x 判断文件是否可执行</p>
</blockquote>

<h2 id="rewrite基本语法"><a href="#rewrite基本语法" class="headerlink" title="rewrite基本语法"></a>rewrite基本语法</h2><div class="hljs"><pre><code class="hljs "><span class="hljs-keyword">set</span>  
<span class="hljs-keyword">if</span>  
<span class="hljs-keyword">return</span>
<span class="hljs-keyword">break</span>
rewrite</code></pre></div>

<h3 id="break指令"><a href="#break指令" class="headerlink" title="break指令"></a>break指令</h3><blockquote><p>使用范围：server，location，if;  </p>
</blockquote> 

<p>中断当前相同作用域的其他nginx配置。 </p>
<h3 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h3><blockquote><p>使用范围：server，location  </p>
</blockquote> 

<p>检查一个条件是否符合。If指令不支持嵌套，不支持多个条件&amp;&amp;和||处理。</p>
<h3 id="return指令"><a href="#return指令" class="headerlink" title="return指令"></a>return指令</h3><blockquote><p>格式：return code ;<br>使用范围：server，location，if;</p>
</blockquote> 

<p>结束规则的执行并返回状态码给客户端。</p>
<h3 id="set指令"><a href="#set指令" class="headerlink" title="set指令"></a>set指令</h3><blockquote><p>使用环境：server，location，if  </p>
</blockquote> 

<p>定义一个变量，并给变量赋值。变量的值可以为文本、变量或者变量的组合。</p>
<div class="hljs"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> <span class="hljs-variable">$var</span> <span class="hljs-string">"hello world"</span></code></pre></div>

<h2 id="rewrite指令格式"><a href="#rewrite指令格式" class="headerlink" title="rewrite指令格式"></a>rewrite指令格式</h2><div class="hljs"><pre><code>rewrite regex replacement [flag]</code></pre></div><p>flag标志位有四种：</p>
<blockquote><p>break：停止rewrite检测,也就是说当含有break flag的rewrite语句被执行时,该语句就是rewrite的最终结果。<br>last：停止rewrite检测,但是跟break有本质的不同,last的语句不一定是最终结果。<br>redirect：返回302临时重定向，一般用于重定向到完整的URL(包含http:部分)<br>permanent：返回301永久重定向，一般用于重定向到完整的URL(包含http:部分) </p>
</blockquote> 

<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>当访问的文件和目录不存在时，重定向到某个php文件</p>
<div class="hljs"><pre><code class="hljs ">if( !-e $request_filename )
&#123;
    rewrite ^/(.*)$ <span class="hljs-keyword">index</span>.php <span class="hljs-keyword">last</span>;
&#125;</code></pre></div>

<p>目录对换 /123456/xxxx ====&gt; /xxxx?id=123456</p>
<div class="hljs"><pre><code class="hljs "><span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/(\d+)/(.+)/</span>  /<span class="hljs-variable">$2</span>?id=<span class="hljs-variable">$1</span> <span class="hljs-literal">last</span>;</code></pre></div>

<p>如果客户端使用的是IE浏览器，则重定向到/ie目录下</p>
<div class="hljs"><pre><code class="hljs "><span class="hljs-keyword">if</span>( <span class="hljs-variable">$http_user_agent</span> ~ MSIE)
&#123;
    rewrite ^(.*)$ <span class="hljs-regexp">/ie/</span><span class="hljs-variable">$1</span> <span class="hljs-keyword">break</span>;
&#125;</code></pre></div>

<p>禁止访问以/data开头的文件</p>
<div class="hljs"><pre><code class="hljs "><span class="hljs-keyword">location</span> <span class="hljs-title">~ ^/data</span>
&#123;
    <span class="hljs-keyword">deny</span> all;
&#125;</code></pre></div>

<p>禁止访问以.sh，.flv，.mp3为文件后缀名的文件</p>
<div class="hljs"><pre><code class="hljs ">location ~ .*\.(sh|<span class="hljs-type">flv</span>|<span class="hljs-type">mp3</span>)$
&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-number">403</span>;
&#125;</code></pre></div>

<p>设置某些类型文件的浏览器缓存时间</p>
<div class="hljs"><pre><code class="hljs ">location ~ .*\.(gif|<span class="hljs-type">jpg</span>|<span class="hljs-type">jpeg</span>|<span class="hljs-type">png</span>|<span class="hljs-type">bmp</span>|<span class="hljs-type">swf</span>)$
&#123;
    expires <span class="hljs-number">30</span>d;
&#125;</code></pre></div>

<p>文件反盗链并设置过期时间</p>
<div class="hljs"><pre><code class="hljs ">location ~*^.+\.(jpg<span class="hljs-params">|jpeg|</span>gif<span class="hljs-params">|png|</span>swf<span class="hljs-params">|rar|</span>zip<span class="hljs-params">|css|</span>js)$ 
&#123;
    valid_referers none blocked *.linuxidc.com*.linuxidc.net localhost <span class="hljs-number">208.97</span>.<span class="hljs-number">167.194</span>;
    <span class="hljs-keyword">if</span> ($invalid_referer) &#123;
        rewrite ^<span class="hljs-regexp">/ http:/</span><span class="hljs-regexp">/img.linuxidc.net/leech</span>.gif;
        <span class="hljs-keyword">return</span> <span class="hljs-number">412</span>;
        <span class="hljs-keyword">break</span>;
    &#125;
    access_log  off;
    root /opt/lampp/htdocs/web;
    expires <span class="hljs-number">3</span>d;
    <span class="hljs-keyword">break</span>;
&#125;</code></pre></div>

<p>将多级目录下的文件转成一个文件，增强seo效果</p>
<div class="hljs"><pre><code class="hljs ">  
/job<span class="hljs-number">-123</span><span class="hljs-number">-456</span><span class="hljs-number">-789.</span>html 指向/job/<span class="hljs-number">123</span>/<span class="hljs-number">456</span>/<span class="hljs-number">789.</span>html

rewrite^/job-([<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+)-([<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+)-([<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+)\.html$ /job/$<span class="hljs-number">1</span>/$<span class="hljs-number">2</span>/jobshow_$<span class="hljs-number">3.</span>html last;</code></pre></div>

<p>域名跳转</p>
<div class="hljs"><pre><code class="hljs "><span class="hljs-section">server</span>
&#123;
    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;
    <span class="hljs-attribute">server_name</span> jump.linuxidc.com;
    <span class="hljs-attribute">index</span> index.html index.htm index.php;
    <span class="hljs-attribute">root</span> /opt/lampp/htdocs/www;
    <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/</span> http://www.linuxidc.com/;
    <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>;
&#125;</code></pre></div>

<p>多域名转向</p>
<div class="hljs"><pre><code class="hljs "><span class="hljs-attribute">server_name</span> www.linuxidc.comwww.linuxidc.net;
<span class="hljs-attribute">index</span> index.html index.htm index.php;
<span class="hljs-attribute">root</span>  /opt/lampp/htdocs;
<span class="hljs-attribute">if</span> (<span class="hljs-variable">$host</span> <span class="hljs-regexp">~ "linuxidc\.net")</span> &#123;
    <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(.*)</span> http://www.linuxidc.com<span class="hljs-variable">$1</span>permanent;
&#125;</code></pre></div>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactor中的上下文</title>
    <url>/2020/09/08/context-of-reactor/</url>
    <content><![CDATA[<p>由于参与的项目当中决定用 <a href="https://github.com/spring-cloud/spring-cloud-gateway" target="_blank" rel="noopener">spring-cloud-gateway</a> 作为网关，所以自然就碰上了Reactor当中获取上下文的问题。    </p>
<p>这里我是遇到了 I18N 需要获取上下文中 Locale 的问题，所以我就以这个问题举例，提供其中一种上下文的解决方法。  </p>
<a id="more"></a>

<h2 id="What-happened"><a href="#What-happened" class="headerlink" title="What happened"></a>What happened</h2><p>在使用 I18N 进行国际化时，Servlet 框架下我们通常会使用 ThreadLocal 进行储存解析请求得到上下文的 Locale 对象，以判断当前请求需要的是什么语言。<br>但在 Reactor 框架下，由于一个请求整个流程下来，线程都在不断的进行切换，所以 THreadLocal 自然也就失去上下文储存对象的能力。</p>
<p>经过简单的谷歌查询，我只能想两种处理方法：  </p>
<ol>
<li>从 controller 获取 Locale 或者任意能够得到 Exchange（类似 Request）的方法开始一路传递下去。</li>
<li>直接将 I18N 的 key 传入自定义异常对象当中，然后在统一异常处理类当中获取 Exchange 再做进一步的国际化操作。</li>
</ol>
<p>但他们都不够优雅，而且其中弊端也很明显，一个是需要无限传递变量，一个是只能限制再异常处理类进行处理，理所当然添加国际化的变量。</p>
<h2 id="How-can-I-do"><a href="#How-can-I-do" class="headerlink" title="How can I do"></a>How can I do</h2><h3 id="如何取值？"><a href="#如何取值？" class="headerlink" title="如何取值？"></a>如何取值？</h3><p>令人喜悦的是，Spring 其实已经写了一个获取上下文的例子了，它就是<code>ReactiveSecurityContextHolder</code>，对应 Servlet 当中的<code>SecurityContextHolder</code>。</p>
<p>ReactiveSecurityContextHolder#getContext</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Class</span>&lt;?&gt; <span class="hljs-type">SECURITY_CONTEXT_KEY</span> = <span class="hljs-type">SecurityContext</span><span class="hljs-class">.<span class="hljs-keyword">class</span>;

<span class="hljs-title">public</span> <span class="hljs-title">static</span> <span class="hljs-title">Mono</span>&lt;<span class="hljs-title">SecurityContext</span>&gt; <span class="hljs-title">getContext</span>() </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-type">Mono</span>.subscriberContext()
            .<span class="hljs-built_in">filter</span>( <span class="hljs-built_in">c</span> -&gt; <span class="hljs-built_in">c</span>.hasKey(<span class="hljs-type">SECURITY_CONTEXT_KEY</span>))       
            .flatMap( <span class="hljs-built_in">c</span>-&gt; <span class="hljs-built_in">c</span>.&lt;<span class="hljs-type">Mono</span>&lt;<span class="hljs-type">SecurityContext</span>&gt;&gt;<span class="hljs-keyword">get</span>(<span class="hljs-type">SECURITY_CONTEXT_KEY</span>));
&#125;</code></pre></div>

<p>可以看到，通过<code>Mono.subscriberContext()</code>，我们可以得到一个上下文对象，然后他先判断是否包含给出的key值，包含则获取值。<br>这里需要注意，如果直接获取值会抛出异常。   </p>
<h3 id="那么它又是如何赋值的呢？"><a href="#那么它又是如何赋值的呢？" class="headerlink" title="那么它又是如何赋值的呢？"></a>那么它又是如何赋值的呢？</h3><p>当我查看<code>withSecurityContext</code>方法时，其注释告诉我时用来创建一个包含<code>SecurityContext</code>的 Reactor 上下文对象（Context）并可被用于与其他上下文对象（Context）进行合并。  </p>
<p>所以当我们查看有什么方法调用它时，就会发现<code>ReactorContextWebFilter</code>这个过滤器。</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReactorContextWebFilter</span> <span class="hljs-title">implements</span> <span class="hljs-title">WebFilter</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSecurityContextRepository repository;

    <span class="hljs-keyword">public</span> ReactorContextWebFilter(ServerSecurityContextRepository repository) &#123;
        Assert.notNull(repository, <span class="hljs-string">"repository cannot be null"</span>);
        <span class="hljs-keyword">this</span>.repository = repository;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Mono&lt;<span class="hljs-built_in">Void</span>&gt; filter(ServerWebExchange exchange, WebFilterChain chain) &#123;
        <span class="hljs-keyword">return</span> chain.filter(exchange)
            .subscriberContext(c -&gt; c.hasKey(SecurityContext<span class="hljs-class">.<span class="hljs-keyword">class</span>) ? <span class="hljs-title">c</span> :
                <span class="hljs-type">withSecurityContext</span></span>(c, exchange)
            );
    &#125;

    <span class="hljs-keyword">private</span> Context withSecurityContext(Context mainContext, ServerWebExchange exchange) &#123;
        <span class="hljs-keyword">return</span> mainContext.putAll(<span class="hljs-keyword">this</span>.repository.load(exchange)
            .<span class="hljs-keyword">as</span>(ReactiveSecurityContextHolder::withSecurityContext));
    &#125;
&#125;</code></pre></div>

<p>ServerSecurityContextRepository#load</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> Mono&lt;SecurityContext&gt; load(ServerWebExchange exchange) &#123;
    <span class="hljs-keyword">return</span> exchange.getSession()
        .map(WebSession::getAttributes)
        .flatMap( attrs -&gt; &#123;
            SecurityContext context = (SecurityContext) attrs.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">this</span>.springSecurityContextAttrName);
            <span class="hljs-keyword">return</span> Mono.justOrEmpty(context);
        &#125;);
&#125;</code></pre></div>

<p>ReactiveSecurityContextHolder#withSecurityContext</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function">Context <span class="hljs-title">withSecurityContext</span><span class="hljs-params">(Mono&lt;? <span class="hljs-keyword">extends</span> SecurityContext&gt; securityContext)</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">return</span> Context.<span class="hljs-title">of</span><span class="hljs-params">(SECURITY_CONTEXT_KEY, securityContext)</span></span>;
&#125;</code></pre></div>

<p>通过阅读上面的代码可得知，上面的过滤器通过<code>ServerSecurityContextRepository</code>解析请求中的 Security 上下文，通过<code>ReactiveSecurityContextHolder</code>生成 Securtiy 上下文对象并返回。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们可以仿照着写一个从请求对象当中解析出一个 Locale 对象并放入上下文当中（不确定是不是上下文，但是Reactor确实是用这种办法实现了上下文的功能）。  </p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">// 将 Locale 放到上下文中</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReactorLocaleContextWebFilter</span> <span class="hljs-title">implements</span> <span class="hljs-title">WebFilter</span> </span>&#123;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Mono&lt;<span class="hljs-built_in">Void</span>&gt; filter(ServerWebExchange exchange, WebFilterChain chain) &#123;
        <span class="hljs-keyword">return</span> chain.filter(exchange)
            .subscriberContext(c -&gt; c.hasKey(Locale<span class="hljs-class">.<span class="hljs-keyword">class</span>) ? <span class="hljs-title">c</span> :
                <span class="hljs-type">withLocaleContext</span></span>(c, exchange)
            );
    &#125;

    <span class="hljs-keyword">private</span> Context withLocaleContext(Context mainContext, ServerWebExchange exchange) &#123;
        <span class="hljs-comment">//解析请求获取 Locale </span>
        Locale locale = getLocale(exchcange);
        <span class="hljs-keyword">return</span> mainContext.putAll(Context.of(Locale<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-type">Mono.justOrEmpty</span></span>(locale)));
    &#125;
&#125;

<span class="hljs-comment">//获取 Locale</span>
Mono.subscriberContext()
            .filter( c -&gt; c.hasKey(Locale<span class="hljs-class">.<span class="hljs-keyword">class</span>))       </span>
            .flatMap( c-&gt; c.&lt;Mono&lt;Locale&gt;&gt;<span class="hljs-keyword">get</span>(Locale<span class="hljs-class">.<span class="hljs-keyword">class</span>));</span></code></pre></div>

<p>具体实现我日后会写一个demo。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Reactor</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reactor</tag>
        <tag>Webflux</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/2017/04/20/Demo/</url>
    <content><![CDATA[<p>test test！！</p>
<a id="more"></a>
<h2 id="ACG"><a href="#ACG" class="headerlink" title="ACG"></a>ACG</h2><h3 id="格子裙赛高！"><a href="#格子裙赛高！" class="headerlink" title="格子裙赛高！"></a>格子裙赛高！</h3><p><img src="/2017/04/20/Demo/COLORS_47646872_p0.jpg" srcset="/img/loading.gif" alt="123"> </p>
<p><a href="http://www.pixiv.net/member_illust.php?mode=medium&illust_id=47646872" target="_blank" rel="noopener">カントク - COLORS(id=47646872)</a></p>
]]></content>
      <categories>
        <category>ACG</category>
      </categories>
      <tags>
        <tag>监督</tag>
        <tag>格子裙</tag>
        <tag>放学五年目</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/03/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="hljs"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre></div>

<!--more-->
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="hljs"><pre><code class="hljs bash">$ hexo server</code></pre></div>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="hljs"><pre><code class="hljs bash">$ hexo generate</code></pre></div>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="hljs"><pre><code class="hljs bash">$ hexo deploy</code></pre></div>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactor处理阻塞问题笔记</title>
    <url>/2020/03/03/lean-pulishOn-of-reactor/</url>
    <content><![CDATA[<p>其实本来想要记录问题的过程，但奈何自己也说不太好XD</p>
<a id="more"></a>
<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>由于接触Vert.x以及阅读其文档后，了解到异步编程下是不能够阻塞主线程的，不然异步将失去意义。</p>
<p>我们需要做的是将这些阻塞线程移到其他线程进行处理。</p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>利用Mono或是Flux的PublishOn方法将之后调用的方法都移动到其他线程进行处理。</p>
<ul>
<li><p><code>publishOn</code></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Mono&lt;T&gt; <span class="hljs-title">publishOn</span><span class="hljs-params">(Scheduler scheduler)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Flux&lt;T&gt; <span class="hljs-title">publishOn</span><span class="hljs-params">(Scheduler scheduler)</span></span>;</code></pre></div>

<p>其中<code>Scheduler</code>可用<code>Schedulers.parallel()</code>或<code>Schedulers.single()</code>进项创建或是其他方法，其中<code>single</code>和<code>parallel</code>是有一些区别的。</p>
<ul>
<li><p><code>single</code></p>
<p>这一条调用链下不会同时执行，并且只有这条调用链执行完成后才会再次被调用</p>
</li>
<li><p><code>parallel</code></p>
<p>与上面相反，调用链会在同时执行</p>
</li>
</ul>
<p>下面是测试代码</p>
<p><del>本人只是刚开始玩reactor，程序写的很蹩脚XD</del></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    AtomicReference&lt;Employee&gt; employeeAR = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(); <span class="hljs-comment">//&lt;1&gt;</span>
    Scheduler scheduler = Schedulers.single(); <span class="hljs-comment">//&lt;2&gt;</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
      <span class="hljs-keyword">int</span> finalI = i;
      Mono.just(<span class="hljs-number">1</span>)
          .publishOn(scheduler)
          .map(x -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
              Thread.sleep(<span class="hljs-number">1000</span>);
              System.out.println(finalI + <span class="hljs-string">"-"</span> + Thread.currentThread()
                  .getName() + <span class="hljs-string">"-A"</span>); <span class="hljs-comment">//&lt;3&gt;</span>
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
              e.printStackTrace();
            &#125;
            Employee emp = buildEmployee();
            employeeAR.set(emp); <span class="hljs-comment">//&lt;1&gt;</span>
            <span class="hljs-keyword">return</span> emp;
          &#125;)
          .map(x -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
              System.out.println(finalI + <span class="hljs-string">"-"</span> + Thread.currentThread()
                  .getName() + <span class="hljs-string">"-B"</span>); <span class="hljs-comment">//&lt;3&gt;</span>
              Thread.sleep(<span class="hljs-number">1000</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
              e.printStackTrace();
            &#125;
            <span class="hljs-keyword">return</span> x;
          &#125;)
          .map(x -&gt; &#123;
            System.out.println(finalI + <span class="hljs-string">"-"</span> + Thread.currentThread()
                .getName() + <span class="hljs-string">"-C"</span>); <span class="hljs-comment">//&lt;3&gt;</span>
            <span class="hljs-keyword">return</span> employeeAR.get().getAccountId(); <span class="hljs-comment">//&lt;1&gt;</span>
          &#125;)
          .subscribe(System.out::println);

      System.out.println(Thread.currentThread()
          .getName());  <span class="hljs-comment">//&lt;3&gt;</span>
    &#125;
    <span class="hljs-keyword">char</span> c = (<span class="hljs-keyword">char</span>) System.in.read();
    System.out.println(<span class="hljs-string">"your char is: "</span> + c);
  &#125;</code></pre></div>

<ul>
<li>&lt;1&gt; 因为涉及到匿名方法中的变量的再次调用，所以用到AtomicReference进行储存。</li>
</ul>
<p>下面是<code>single</code>的运行结果</p>
<div class="hljs"><pre><code class="hljs undefined">main
main
main
main
main
<span class="hljs-number">0</span>-single<span class="hljs-number">-1</span>-A
<span class="hljs-number">0</span>-single<span class="hljs-number">-1</span>-B
<span class="hljs-number">0</span>-single<span class="hljs-number">-1</span>-C
<span class="hljs-number">123</span>
<span class="hljs-number">1</span>-single<span class="hljs-number">-1</span>-A
<span class="hljs-number">1</span>-single<span class="hljs-number">-1</span>-B
<span class="hljs-number">1</span>-single<span class="hljs-number">-1</span>-C
<span class="hljs-number">123</span>
<span class="hljs-number">2</span>-single<span class="hljs-number">-1</span>-A
<span class="hljs-number">2</span>-single<span class="hljs-number">-1</span>-B
<span class="hljs-number">2</span>-single<span class="hljs-number">-1</span>-C
<span class="hljs-number">123</span>
<span class="hljs-number">3</span>-single<span class="hljs-number">-1</span>-A
<span class="hljs-number">3</span>-single<span class="hljs-number">-1</span>-B
<span class="hljs-number">3</span>-single<span class="hljs-number">-1</span>-C
<span class="hljs-number">123</span>
<span class="hljs-number">4</span>-single<span class="hljs-number">-1</span>-A
<span class="hljs-number">4</span>-single<span class="hljs-number">-1</span>-B
<span class="hljs-number">4</span>-single<span class="hljs-number">-1</span>-C
<span class="hljs-number">123</span></code></pre></div>

<p>将&lt;2&gt;中<code>single</code>改为<code>parallel</code></p>
<div class="hljs"><pre><code class="hljs undefined">main
main
main
main
main
<span class="hljs-number">0</span>-parallel<span class="hljs-number">-1</span>-A
<span class="hljs-number">3</span>-parallel<span class="hljs-number">-4</span>-A
<span class="hljs-number">2</span>-parallel<span class="hljs-number">-3</span>-A
<span class="hljs-number">4</span>-parallel<span class="hljs-number">-5</span>-A
<span class="hljs-number">0</span>-parallel<span class="hljs-number">-1</span>-B
<span class="hljs-number">3</span>-parallel<span class="hljs-number">-4</span>-B
<span class="hljs-number">2</span>-parallel<span class="hljs-number">-3</span>-B
<span class="hljs-number">1</span>-parallel<span class="hljs-number">-2</span>-A
<span class="hljs-number">1</span>-parallel<span class="hljs-number">-2</span>-B
<span class="hljs-number">4</span>-parallel<span class="hljs-number">-5</span>-B
<span class="hljs-number">0</span>-parallel<span class="hljs-number">-1</span>-C
<span class="hljs-number">1</span>-parallel<span class="hljs-number">-2</span>-C
<span class="hljs-number">3</span>-parallel<span class="hljs-number">-4</span>-C
<span class="hljs-number">4</span>-parallel<span class="hljs-number">-5</span>-C
<span class="hljs-number">2</span>-parallel<span class="hljs-number">-3</span>-C
<span class="hljs-number">123</span>
<span class="hljs-number">123</span>
<span class="hljs-number">123</span>
<span class="hljs-number">123</span>
<span class="hljs-number">123</span></code></pre></div>

<p>观察代码中&lt;3&gt;，我们可以发现调用链当中是按照顺序执行的（我最开始以为会平行执行调用链中的方法，但并不是），而且主线程也没有被阻塞，能够快速输出当前线程名称，由此可见已经达到我们最初的目的了——不阻塞主线程。</p>
</li>
</ul>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>在这里我用的是Spring WebFlux，而其中会用到netty，其中有一个Eventloop模块，这是由单个线程运行的模块，这个单线程就是由我们程序所运行的主线程来担当。</p>
<p>Eventloop会重复检查当前有没有事件产生，若有则会接收该事件并运行相应的事件响应，也就是发布订阅模式，而如果我们在其中一个调用该事件的响应方法中等待（阻塞）过久，就会导致我们无法快速处理后续产生的事件，只能够加多线程进行快速处理，这就又回到了非异步编程当中去了。</p>
<p>所以能够快速响应才能够体现出异步编程的优势。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://github.com/reactor/reactor-core/issues/1756" target="_blank" rel="noopener">Is there a standard way to solve blocking that must happen.</a></li>
<li><a href="https://stackoverflow.com/questions/56706308/how-to-handle-blocking-calls-when-using-reactor-in-a-jax-rs-powered-server" target="_blank" rel="noopener">How to handle blocking calls when using reactor in a JAX-RS-powered server?</a></li>
</ul>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li><input disabled type="checkbox"> 测试嵌套调用publishiOn是什么情况  </li>
<li><input disabled type="checkbox"> 是否是调用一次publishOn后，后面的链式调用都是在另一条线程，是否需要再次调用一次pubulishOn保证之后的一次阻塞操作也不在主线程当中  </li>
<li><input disabled type="checkbox"> 补充详细Evenloop  </li>
<li><input disabled type="checkbox"> 寻找更加优雅的方式，或者看看这种链式调用是不是也是一个不太好的地方  </li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Reactor</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reactor</tag>
        <tag>Webflux</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>とある三秋 缒の摘抄</title>
    <url>/2017/05/20/%E3%81%A8%E3%81%82%E3%82%8B%E4%B8%89%E7%A7%8B%20%E7%BC%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%91%98%E6%8A%84/</url>
    <content><![CDATA[<p>记录一下比较打动我的一些段落</p>
<a id="more"></a>
<blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>&emsp;&emsp;这世上到处都有地洞，至少世界看在我眼里就是这样。有的洞小，有的洞大；有的洞浅，有的洞深；有的洞很明显，有的洞不明显；有的洞尚有人掉进去，有的洞已经有许多人掉进去。真的是五花八门。一旦想着这一个个地洞，就会让我满心不安，一步都不想动了。<br>&emsp;&emsp;孩提时代，我喜欢那种会让我忘记地洞存在的故事。看来不只是我，大家都喜欢看那种书中世界的所有地洞都已经加盖的故事，也不知道是不是该叫“杀菌过的故事”。当然主角不会只遇到好事，经历的各种痛苦与难受的体验也不会比别人少，但最终来说，这一切都将成为他成长的动力，让读者可以沉浸在“人就是要接受一切勇敢活下去”这种可靠的感觉中。我说的就是这种故事。<br>&emsp;&emsp;我想我们一定是不希望连在虚构的世界都要经历悲伤<br>&emsp;&emsp;可是有一天，我发现自己不知不觉地身在阴暗的地洞中。那是一种没有任何前兆、没有天理可言的失足。由于那是个非常小且不起眼的地洞，很难指望会有别人帮助。所幸这个地洞并不是深到爬不出来，我花了很长时间，靠自己的力量终于脱身。<br>&emsp;&emsp;来到地上后，我沐浴在久违的温暖阳光与清澈的徐风中，因而产生这样的想法。无论多么小心，都没有人知道何时会掉进地洞。这个世界就是这样的地方。下次我说不定会掉进一个更深的洞，深得让我再也回不到地面上。到时候，我该怎么办呢？<br>&emsp;&emsp;从此之后，我就再也无法怀着以往那样单纯的心情，去看待那些“把地洞加了盖的故事”。相对地，我开始喜欢描写“在地洞里过的好像很幸福的人”的故事。因为我想听的是在阴暗、深邃、狭窄又寒冷的地洞里，不用逞强也能露出微笑的人身上所发生的故事。也许对现在的我来说，再也没有什么比这个更能安慰我了。</p>
<footer><strong>三秋 缒</strong><cite>いたいのいたいの、とんでゆけ</cite></footer></blockquote>
]]></content>
      <tags>
        <tag>三秋 缒</tag>
        <tag>摘抄</tag>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title>将项目部署在docker中</title>
    <url>/2019/03/14/%E5%B0%86%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8docker%E4%B8%AD/</url>
    <content><![CDATA[<p>docker中有两个概念，容器与镜像。 </p>
<p>镜像我们可以简单的理解为是装机用的光盘，而容器就是我们用光盘所装的一个系统。实际上我们就是由镜像生成一个容器，一个镜像可以生成多个容器（只要容器互不相冲突）。</p>
<p>而镜像的生成就是由配置文件来决定（配置文件参数可由后期运行指令等等操作更改），具体如何配置不详细说明。</p>
<a id="more"></a>
<blockquote>
<p>Banner: <a href="http://www.pixiv.net/member_illust.php?mode=medium&illust_id=47646872" title="カントク - COLORS" target="_blank" rel="noopener">カントク - COLORS</a></p>
</blockquote>
<p>配置文件例子<br>Dockerfile</p>
<div class="hljs"><pre><code class="hljs dockerfile"><span class="hljs-comment">#后端java项目</span>

<span class="hljs-comment">#基础镜像</span>
<span class="hljs-keyword">FROM</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">1.2</span>:<span class="hljs-number">5000</span>/library/centos-jdk:<span class="hljs-number">1.7</span>.<span class="hljs-number">79</span>
<span class="hljs-comment">#作者</span>
<span class="hljs-keyword">MAINTAINER</span> kurenai kurenai@moe.com
<span class="hljs-comment">#执行命令，主要用来安装相关的软件</span>
<span class="hljs-comment">#RUN </span>
<span class="hljs-comment">#添加文件</span>
<span class="hljs-keyword">ADD</span><span class="bash"> target/supervise-svc-0.0.1-SNAPSHOT.jar /usr/<span class="hljs-built_in">local</span></span>
<span class="hljs-keyword">RUN</span><span class="bash"> chmod u+x /usr/<span class="hljs-built_in">local</span>/supervise-svc-0.0.1-SNAPSHOT.jar</span>
<span class="hljs-comment">#挂载目录到容器</span>
<span class="hljs-comment">#VOLUME ["/data"]</span>
<span class="hljs-comment">#环境变量设置</span>
<span class="hljs-comment">#ENV </span>
<span class="hljs-comment">#开放端口</span>
<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">1234</span>
<span class="hljs-comment">#启动时执行的命令</span>
<span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"/bin/bash"</span>]</span>
<span class="hljs-comment">#启动时执行的命令</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">"java"</span>,<span class="hljs-string">"-jar"</span>,<span class="hljs-string">"-Xms2048m"</span>, <span class="hljs-string">"-Xmx2048m"</span>, <span class="hljs-string">"-XX:PermSize=256M"</span>, <span class="hljs-string">"-XX:MaxPermSize=256M"</span>,<span class="hljs-string">"/usr/local/supervise-svc-0.0.1-SNAPSHOT.jar"</span>]</span></code></pre></div>

<div class="hljs"><pre><code class="hljs dockerfile"><span class="hljs-comment">#前端react项目</span>

<span class="hljs-comment">#基础镜像</span>
<span class="hljs-keyword">FROM</span> xxx.xxx.com:<span class="hljs-number">5000</span>/library/ui-nginx:latest

<span class="hljs-comment">#维护人信息</span>
<span class="hljs-keyword">MAINTAINER</span> WenboLI liwenbo@ly-sky.com

<span class="hljs-comment">#工作目录</span>
<span class="hljs-keyword">WORKDIR</span><span class="bash"> /usr/<span class="hljs-built_in">local</span>/nginx</span>

<span class="hljs-keyword">ADD</span><span class="bash"> ui.tar.gz /usr/<span class="hljs-built_in">local</span>/nginx/html/</span>

<span class="hljs-keyword">ADD</span><span class="bash"> nginx.conf /usr/<span class="hljs-built_in">local</span>/nginx/conf/</span>

<span class="hljs-comment">#暴露端口</span>
<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span>

<span class="hljs-comment">#连接时执行的命令</span>
<span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"/bin/bash"</span>]</span>

<span class="hljs-comment">#启动时执行的命令</span>
<span class="hljs-comment">#ENTRYPOINT nginx -g "daemon off;"</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> /opt/run.sh</span></code></pre></div>

<ul>
<li>基础命令</li>
</ul>
<div class="hljs"><pre><code class="hljs bash">docker ps       <span class="hljs-comment">#查看doker中正在运行的容器列表</span>
docker images   <span class="hljs-comment">#查看docker中的镜像列表</span>
docker build    <span class="hljs-comment">#将当前目录下的文件打包为镜像</span>
docker rm       <span class="hljs-comment">#移除容器</span>
docker rmi      <span class="hljs-comment">#移除镜像</span>
docker pull     <span class="hljs-comment">#拉取镜像</span>
docker logs -f  <span class="hljs-comment">#查看日志</span>
docker restart  <span class="hljs-comment">#重启容器</span>
docker stop     <span class="hljs-comment">#停止容器运行</span></code></pre></div>

<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>能够比较集中的管理镜像和容器的部署问题，不必用像原生docker那样一个一个项目进行打包镜像生成容器，只需要把n个项目的配置写在配置文件中即可进行批量打包，拉取镜像，生成容器</p>
<p>配置文件例子<br>docker-compose.yml</p>
<div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'2.2'</span>
<span class="hljs-attr">services:</span>
  <span class="hljs-comment">#项目名称，用docker-compose做管理时，每个项目用这里配置的名称进行单独管理</span>
  <span class="hljs-attr">base:</span>
    <span class="hljs-comment">#镜像名，拉取镜像时也是用这个名字作为地址</span>
    <span class="hljs-attr">image:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span><span class="hljs-string">:5000/test/base-svc:0.0.1-SNAPSHOT</span> 
    <span class="hljs-comment">#打包路径，即docker build的路径</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">/opt/dockerfile/base-svc</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>
    <span class="hljs-comment">#环境变量</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://192.168.1.3:1200/eureka/</span>
    <span class="hljs-comment">#开放端口</span>
    <span class="hljs-attr">ports:</span> 
      <span class="hljs-bullet">-</span> <span class="hljs-string">"1430:1430"</span>
    <span class="hljs-comment">#网络连接模式</span>
    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">"bridge"</span>

  <span class="hljs-attr">supervise:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span><span class="hljs-string">:5000/test/supervise-svc:0.0.1-SNAPSHOT</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">/opt/dockerfile/supervise-svc</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://192.168.1.3:1200/eureka/</span>
    <span class="hljs-attr">ports:</span> 
      <span class="hljs-bullet">-</span> <span class="hljs-string">"1570:1570"</span>
    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">"bridge"</span></code></pre></div>

<ul>
<li>常用命令</li>
</ul>
<div class="hljs"><pre><code class="hljs bash">docker-copmpose build       <span class="hljs-comment">#打包镜像，后面不加项目名则打包所有配置了build的项目，可接多个项目名，用空格隔开</span>
docker-compose up -d        <span class="hljs-comment">#后台运行项目，寻找本地镜像生成容器（若镜像更新则重启用新镜像生成容器），或者docker-compose.yml文件改变了也会进行更新容器，同样不接项目名为所有项目，也可以接多个项目名</span>
docker-compose logs -f      <span class="hljs-comment">#查看日志，同上可接项目名</span>
docker-compose pull         <span class="hljs-comment">#拉取镜像，同上可接项目名</span>
docker-compose restart      <span class="hljs-comment">#重启容器，同上</span>
docker-compose stop         <span class="hljs-comment">#停止运行容器，同上</span></code></pre></div>

<h2 id="实际生产环境部署项目"><a href="#实际生产环境部署项目" class="headerlink" title="实际生产环境部署项目"></a>实际生产环境部署项目</h2><p><code>/opt/dockerfile</code>文件夹下是每个项目的目录，每个目录下是一个Dockerfile配置文件+打包的项目文件（java为.jar, react为tar.gz, 视项目和配置文件而定）</p>
<p><code>/opt/cloud</code>目录下是分的几个类，把几个项目归为一起，项目下是docker-compose.yml配置文件</p>
<p>以后端java项目<code>meeting-svc</code>为例 </p>
<ol>
<li>打包项目为jar包，</li>
<li>将jar包放在<code>/opt/dockerfile/meeting-svc</code>目录下</li>
<li>进入到<code>/opt/cloud/service</code></li>
<li>运行指令<code>docker-compose build meeting</code>(配置文件中配置的项目名为<code>meeting</code>)打包镜像</li>
<li>运行<code>docker-compose up -d meeting</code>更新容器并运行</li>
<li>用<code>docker-compose logs -f meeting</code>进行查看日志</li>
</ol>
<hr>
<p>ps： 后端打包为tar -zcvf xxx.tar.gz -C dist/ .      #dist为编译文件目录</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>ops</tag>
      </tags>
  </entry>
</search>
